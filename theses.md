# Преамбула

Предполагается, что студент имеет базовые знания веб-технологий (HTML, CSS, JavaScript) и практические навыки решения задач с помощью базовых алгоритмов и структур данных.

Проектная работа выполняется в группах по 2–3 человека (роли каждого должны быть представлены при формировании группы). Первое практическое занятие – индивидуальное.

Для выполнения проектной работы на занятиях потребуется ноутбук/виртуальная машина с установленной ОС Linux/OS X.

Ресурсы для самостоятельного изучения:

1. Влад Мержевич. [Самоучитель HTML4](http://htmlbook.ru/samhtml) // 2010.
2. Влад Мержевич. [Самоучитель CSS](http://htmlbook.ru/samcss) // 2010.
3. Илья Кантор. [Современный учебник JavaScript](http://learn.javascript.ru) // 2013.
4. Антон Шевчук. [jQuery для начинающих](http://anton.shevchuk.name/jquery-book/) // 2013.
5. [Mozilla Developer Network](https://developer.mozilla.org/).
6. [HTML5 Rocks](http://www.html5rocks.com/).
7. Mark Piligrim. [Dive into HTML5](http://diveintohtml5.info) // 2013.

# 1 Архитектура

## 1.1 Знакомство, инструменты, настройка окружения

#### Полезные ресурсы

1. Scott Chacon. [Pro Git](http://git-scm.com/book) // 2009.
2. [Grunt: Getting started](http://gruntjs.com/getting-started) // 2013.
3. Документация по [NPM](https://npmjs.org/doc/cli/npm.html) и [`package.json`](https://npmjs.org/doc/files/package.json.html).
4. Документация по шаблонизатору [Fest](https://github.com/mailru/fest).
5. Антон Шевчук. [jQuery для начинающих](http://anton.shevchuk.name/jquery-book/) // 2013.

### Лекция

Меня зовут Антон Епрев, в компании Mail.ru я руковожу группой фронтенд разработчиков проекта «Почта». Вести курс мне будут помогать мои коллеги: Егор Дыдыкин и Иван Чашкин. Егор руководит разработкой главной страницы Mail.ru и портальной навигацией, умеет делать такие веб-страницы, которые браузер быстро загружает и отрисовывает. Иван занимается разработкой веб-версии почты для смартфонов, знает если не абсолютно все, то безусловно очень много про особенности мобильных браузеров.

Курс фронтенд разработки состоит из трех модулей, восьми совмещенных занятий (на которых лекционная часть и практическая будут идти вместе), трех контрольных рубежей и презентации проекта. В общей сложности курс состоит из двенадцати занятий.

Обращаю ваше внимание, что на совмещенных занятиях будет вестись видеосъемка.

Сегодняшнее совмещенное занятие будет посвящено знакомству с курсом, инструментам и настройке рабочего окружения.

Дадим определение основных понятий.

Веб-приложение — клиент-серверное приложение, в котором клиентом выступает браузер, а сервером — веб-сервер. Логика веб-приложения распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, обмен информацией происходит по сети. Одним из преимуществ такого подхода является тот факт, что клиенты не зависят от конкретной операционной системы пользователя, поэтому веб-приложения являются межплатформенными сервисами [[Википедия](http://ru.wikipedia.org/wiki/Веб-приложение)].

Этот курс посвещен разработке той части веб-приложения, которая работает на стороне клиента – в браузере. От сюда и название – клиент-сайд. Другое название – front-end, тогда как часть веб-приложения, работающая на стороне сервера, называется back-end.

В результате изучения курса вы освоите современную разработку клиент-сайда веб-приложений; узнаете тонкости технологий HTTP, HTML 5, CSS 3, JavaScript, DOM, Events, Host Objects, AJAX; получите необходимую базу знаний о работе браузера (десктоп, смартфоны, планшеты), клиент-серверной архитектуре, архитектуре веб-приложений (события, модули, организации кода) и приобретёте  навыки работы с DOM, асинхронного и событийно-ориентированного программирования, сетевого взаимодествия (AJAX, WebSockets), организации многопоточности в браузере, использования CSS препроцессоров, отладки веб-приложений и сборки проекта с помощью Grunt для раскладки на сервер.

Для успешной сдачи курса необходимо самостоятельно реализовать клиен-сайд для однопользовательской игры с использованием смартфона в качестве игрового контроллера.

На протяжении всего семестра у вас будет три контрольных рубежа. Каждый рубежный контроль вместе с выполнением части проектной работы сопроваждается устным контроллем знаний. Прохождение первого контрольного рубежа дает возможность пройти второй рубеж, второго – третий. Программа предполагает своевременную сдачу каждого контрольного рубежа. Итоговый рейтинг по дисциплине представляет собой сумму баллов, полученных за прохождение рубежных контролей и домашних заданий. Для успешной аттестации по данному курсу студентам необходимо набрать пороговый рейтинг — 60 баллов. При пересчете баллов студенты могут получить итоговую оценку: 0–59 неудовлетворительно, 60–74 удовлетворительно, 75–89 хорошо, 90–100 отлично.

Каковы критерии оценки при прохождении рубежного контроля?

1. Соответствие результата предъявляемым требованиям.
2. Оптимальность предлагаемого решения.
3. Практичность решения (возможность дальнейшего применения в работе).
4. Качество оформления результатов работы.
5. Доказательность аргументации при защите работы.

Проектная работа ведется в группах по 2–3 человека (роли каждого должны быть представлены при формировании группы).

Вводная часть занятия окончена. Переходим в основной части.

Долгое время JavaScript был прерогативой клиент-сайда. Но с выходом [Node.js](http://nodejs.org) появилась возможность использовать JavaScript для написания высокопроизводительных приложений, исполняющихся на стороне сервера. С помощью языка программирования, которым владеет каждый фронтед разработчик, теперь стало возможным создавать различные инструметы, такие как системы сборки проекта, его тестирования и развертывания. Сегодня JavaScript является [самым популярным языком программирования](http://adambard.com/blog/top-github-languages-for-2013-so-far/) среди создаваемых на GitHub проектов.

Вместе с дистрибутивом Node.js распространяется и [NPM](https://npmjs.org) (Node Packaged Modules) — это менеджер пакетов для Node.js. У Java есть Maven, CPAN у Perl, а у Python есть pip, так и у разработчиков на Node.js есть NPM.

В качестве системы контроля верский кода мы будем использовать Git. Эту и следующие презентации вы сможете найти на [GitHub](https://github.com/eprev/frontend).

У каждого из вас уже имеется опыт разработки клиент-сайда, возможно, у кого-то этот опыт не ограничивается проектом, выполненным в прошлом семестре в рамках курса веб-технологий. И скорее всего, проект этот несложный. Такие проекты, обычно, состоят из одного-двух JavaScript файлов и CSS файла со стилями, которые браузер загружает по отдельности вместе с HTML кодом страницы. Такой подход перестает работать, когда проект начинает насчитывать тысячи строк кода JavaScript и стилей CSS. Работать с такими большими файлами неудобно, поэтому, как и в ситуации с программами, написанными на других языках программирования, прибегают к разбиению кода на модули, каждый из которых хранится в отдельном файле. Теперь для функционирования веб-приложения в браузере было бы необходимо загрузить десятки, а то и сотни, файлов JavaScript и CSS. Как вы должно быть уже знаете — это крайне неэффективно. Поэтому перед развертыванием проекта на сервере необходимо произвести его сборку: объединить множество JavaScript файлов в одну или несколько сборок, так же поступить и с CSS файлами, после чего эти сборки минифицировать. Минификация — это процесс сжатия исходного когда с сохранением его функциональности. Как правило, уменьшение размеры файлов достигается за счет удаления ненужных символов (таких как пробелы, переводы строк и комментарии) и замены имен переменных и функций на короткие варианты. На сегодняшний день самым популярным инструментом для сборки проектов является [Grunt](http://gruntjs.com/). Его без труда может установить каждый, воспользовавшись NPM.

Мы продолжаем двигаться от простых веб-приложений к сложным. Следующим этапом в веб-разработке становится Single Page Application — это веб-приложение, которое живет в браузере продолжительное время без березагрузки страницы. В таком приложении все дополнительные ресурсы загружаются по мере необходимости, а для отрисовки интерфейса используется клиентская шаблонизация. Существует огромное множество JavaScript шаблонизаторов, мы в компании разработали свой. [Fest](https://github.com/mailru/fest) обеспечивает высокую производительность и возможность использования шаблонов на стороне сервера. Например, главная страница Mail.ru формируется на стороне сервера с помощью скомпилированного в JavaScript код фестового шаблона.

### Практика

Создайте директорию для проекта.

```bash
$ mkdir ИМЯ-ПРОЕКТА
```

Создайте [`package.json`](https://npmjs.org/doc/files/package.json.html).

```bash
$ npm init
```

Установите Grunt и `grunt-contrib-connect`.

```bash
$ npm install grunt-cli -g
$ npm install grunt grunt-contrib-connect --save-dev
```

Создайте `Gruntfile.js` и настройте таск `connect`.

```javascript
module.exports = function (grunt) {

    grunt.initConfig({
        connect: {
            server: {
                options: {
                    keepalive: true, /* работать постоянно */
                    port: 8000, /* номер порта */
                    base: 'public' /* публичная директория */
                }
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-connect');

};
```

```bash
$ grunt connect
Running "connect:server" (connect) task
Waiting forever...
Started connect web server on http://localhost:8000
```

Создайте `public/index.html`.

Установите `grunt-fest` и настройте таск `fest`.

```bash
$ npm install grunt-fest --save-dev
```

```javascript
module.exports = function (grunt) {

    grunt.initConfig({
        connect: {
            server: {
                options: {
                    keepalive: true,
                    port: 8000,
                    base: 'public'
                }
            }
        },
        fest: {
            templates: {
                files: [{
                    expand: true,
                    cwd: 'templates', /* исходная директория */
                    src: '*.xml', /* имена шаблонов */
                    dest: 'public/js/tmpl' /* результирующая директория */
                }],
                options: {
                    template: function (data) { /* задаем формат функции-шаблона */
                        return grunt.template.process(
                            'var <%= name %>Tmpl = <%= contents %> ;', /* присваиваем функцию-шаблон переменной */
                            {data: data}
                        );
                    }
                }
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-connect');
    grunt.loadNpmTasks('grunt-fest');

};
```

Установите `grunt-contrib-watch` и настройте таск `watch`.

```javascript
module.exports = function (grunt) {

    grunt.initConfig({
        watch: {
            fest: {
                files: ['templates/*.xml'], /* следим за шаблонами */
                tasks: ['fest'], /* перекомпилировать */
                options: {
                    atBegin: true /* запустить задачу при старте */
                }
            }
        },
        connect: {
            server: {
                options: {
                    port: 8000,
                    base: 'public'
                }
            }
        },
        fest: {
            templates: {
                files: [{
                    expand: true,
                    cwd: 'templates',
                    src: '*.xml',
                    dest: 'public/js/tmpl'
                }],
                options: {
                    template: function (data) {
                        return grunt.template.process(
                            'var <%= name %>Tmpl = <%= contents %> ;',
                            {data: data}
                        );
                    }
                }
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.loadNpmTasks('grunt-contrib-connect');
    grunt.loadNpmTasks('grunt-fest');

    grunt.registerTask('default', ['connect', 'watch']); /* задача по умолчанию */

};
```

Добавьте [`livereload`](https://github.com/gruntjs/grunt-contrib-watch#optionslivereload).

```javascript
module.exports = function (grunt) {

    grunt.initConfig({
        watch: {
            fest: {
                files: ['templates/*.xml'],
                tasks: ['fest'],
                options: {
                    atBegin: true
                }
            },
            server: {
                files: [
                    'public/js/**/*.js', /* следим за статикой */
                    'public/css/**/*.css'
                ],
                options: {
                    interrupt: true,
                    livereload: true /* перезагрузить страницу */
                }
            }
        },
        connect: {
            server: {
                options: {
                    livereload: true, /* поддержка перезагрузки страницы */
                    port: 8000,
                    base: 'public'
                }
            }
        },
        fest: {
            templates: {
                files: [{
                    expand: true,
                    cwd: 'templates',
                    src: '*.xml',
                    dest: 'public/js/tmpl'
                }],
                options: {
                    template: function (data) {
                        return grunt.template.process(
                            'var <%= name %>Tmpl = <%= contents %> ;',
                            {data: data}
                        );
                    }
                }
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.loadNpmTasks('grunt-contrib-connect');
    grunt.loadNpmTasks('grunt-fest');

    grunt.registerTask('default', ['connect', 'watch']);

};
```

Подключите [jQuery](http://jquery.com). Создайте функции для отрисовки каждого из экранов игры.

```javascript
var $page = $('.page');

/* Конструктор экрана "Лучшие игроки" */
function showScoreboardScreen() {
    hideMainScreen();
}

/* Деструктор экрана "Лучшие игроки" */
function hideScoreboardScreen() {}

/* Конструктор экрана "Игра" */
function showGameScreen() {
    hideMainScreen();
}

/* Деструктор экрана "Игра" */
function hideGameScreen() {}

/* Конструктор экрана "Главный" */
function showMainScreen() {
    $page.html(mainTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-scoreboard').on('click', showScoreboardScreen);
    $page.find('.js-start-game').on('click', showGameScreen);
}

/* Деструктор экрана "Главный" */
function hideMainScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-scoreboard').off('click', showScoreboardScreen);
    $page.find('.js-start-game').off('click', showGameScreen);
}

showMainScreen();
```

Заключительный вариант.

```javascript
var $page = $('.page'),
    currentScreen = 'main';

/* Конструктор экрана "Лучшие игроки" */
function showScoreboardScreen() {
    hideMainScreen(); // Убиваем экран "Главный"
    currentScreen = 'scoreboard';
    $page.html(scoreboardTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-back').on('click', showMainScreen);
}

/* Деструктор экрана "Лучшие игроки" */
function hideScoreboardScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-back').off('click', showMainScreen);
}

/* Конструктор экрана "Игра" */
function showGameScreen() {
    hideMainScreen(); // Убиваем экран "Главный"
    currentScreen = 'game';
    $page.html(gameTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-back').on('click', showMainScreen);
}

/* Деструктор экрана "Игра" */
function hideGameScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-back').off('click', showMainScreen);
}

/* Конструктор экрана "Главный" */
function showMainScreen() {
     // Убиваем текущий экран
    if (currentScreen === 'scoreboard') {
        hideScoreboardScreen();
    } else if (currentScreen === 'game') {
        hideGameScreen();
    }
    currentScreen = 'main';
    $page.html(mainTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-scoreboard').on('click', showScoreboardScreen);
    $page.find('.js-start-game').on('click', showGameScreen);
}

/* Деструктор экрана "Главный" */
function hideMainScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-scoreboard').off('click', showScoreboardScreen);
    $page.find('.js-start-game').off('click', showGameScreen);
}

showMainScreen();
```

### Домашнее задание

1. Сформировать идею игры.
2. Определиться с группой и ролями в ней.
3. Создать прототип веб-приложения.

### Техническое задание

1. Прототип состоит из трех экранов:
    1. Главный экран (Main Screen). Содержит название игры и пункты главного меню:
        - Пункт «Лучшие игроки» ведет на экран «Лучшие игроки».
        - Пункт «Начать игру» ведет на основной экран игры.
    2. Лучшие игроки (Scoreboard Screen). Содержит название игры и кнопку «Назад», ведущую на главный экран.
    3. Основной экран игры (Game Screen). Содержит кнопку «Назад», ведущую на главный экран.
2. За отрисовку и последующую инициализацию каждого экрана должна отвечать отдельная функция в JavaScript.
3. При первой загрузке страницы с игрой появляется главный экран. Переход между экранами должен осуществлятся без перезагрузки страницы.
4. Для шаблонизации на строне клиента должен использоваться Fest (см. [`grunt-fest`](https://npmjs.org/package/grunt-fest) и [Fest](https://github.com/mailru/fest)).
5. На странице с игрой допускается загрузка одного JavaScript файла и одного CSS файла. Сборку этих файлов необходимо осуществить с помощью Grunt (см. [`grunt-contrib-concat`](http://npmjs.org/package/grunt-contrib-connect)).
6. С помощиью Grunt возможно запустить веб-сервер с игрой (см. [`grunt-contrib-connect`](https://npmjs.org/package/grunt-contrib-connect)). Страницу с игрой необходимо автоматически перезагружать при изменении исходных JavaScript, XML (Fest) или CSS файлов (см. параметр `livereload` в задачах `grunt-contrib-connect` и [`grunt-contrib-watch`](https://npmjs.org/package/grunt-contrib-watch)).

![Схема прототипа](/pics/prototype-scheme.png)

## 1.2 Архитектура веб-приложений

- Глобальная область видимости.
- Модули.
- БЭМ.
- [PubSub](http://en.wikipedia.org/wiki/Publish–subscribe_pattern).
- [MVC](http://ru.wikipedia.org/wiki/Model-View-Controller).
- [Backbone](http://backbonejs.org).

Глобальные переменные в JavaScript доступны везде, локальные — только в области видимости, в которой они определены. Глобальные переменные являются свойствамии объекта `window`. Поэтому, объявляя глобальные переменные, вы рискуете изменить свойства `window`. Каждый раз при присвоении значения неопределенной локальной переменной, вы создаете или изменяете глобальную. Использование глобальных переменных является плохой практикой. В текущей спецификации JavaScript отсутствуют модули, которые бы разграничивали области видимости переменных, объявленых внутри. Но существуют несколько приемов, позволяющих реализовать модульность.

```JavaScript
var foo = 1;
(function (window, undefined) {
    var foo = 2;
    alert(foo); // 2
})(window);
alert(foo); // 1
```

Конструкция в примере выше называется *немедленно-вызываемая функция* (Immediately-Invoked Function Expression, IIFE). Мы создаем анонимную функцию и незамедлительно вызываем ее, с параметрами или без.

Пока что наша функция ничего не возвращает, и модулем назвать ее сложно. Рассмотрим пример по сложнее.

```JavaScript
var foo = 1;
var module = (function (window, undefined) {
        var foo = 2; // приватная переменная
        return {
            say: function () { // публичный метод
                alert(foo); // 2
            }
        };
    })(window);
alert(foo); // 1
```

На этот раз немедленно-вызываемая функция возвращает объект, определяющий интерфейс модуля, с которым уже можно работать в других частях веб-приложения. Такой подход предотвращает попадание приватных переменных и функций в глобальный контекст, где они могут конфликтовать с другими интерфейсами.

В отличии от некоторых других языков программирования, JavaScript не поддерживает модификаторы доступа. Область видимости ограничивает доступность объявленных в ней переменных. Таким образом, объявленные внутри модуля переменные и функции доступны только изнутри этого модуля, а свойства объекта, возвращаемого модулем, будут доступны всем.

Как устроено сложное веб-приложение?

Уровень библиотек. 
Уровень ядра приложения.
Уровень модулей.

> Модуль — функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом… предназначенный для использования в других программах [[Википедия](http://ru.wikipedia.org/wiki/Модуль_(программирование\))].

Модуль веб-приложения состоит из HTML, CSS и JavaScript – блок в терминологии БЭМ. Модули характеризуются [связанностью](http://ru.wikipedia.org/wiki/Связанность_(программирование\)). Слабая связанность позволяет вносить изменения в один модуль не оказывая при этом влияния на остальные. 

Веб-приложение представляем собой результат работы модулей из которых оно состоит.

Когда модули слабо связаны между собой, то удаление одного, не приведет к некорректной работе остальные модули.

Ядро веб-приложения отвечает за управление модулями (загрузка, инициализация и освобождение ресурсов), предоставляет средства коммуникации между модулями и занимается обработкой ошибок в приложении.

На уровне библиотек находятся инструменты для работы с DOM, AJAX, парсеры и т.п.

Литература:

1. Addy Osmani. [Patterns For Large-Scale JavaScript Application Architecture](http://addyosmani.com/largescalejavascript/) // 2011.
2. Эдди Османи. [Паттерны для масштабируемых JavaScript-приложений](http://largescalejs.ru) // 2011.
3. Addy Osmani. [Developing Backbone.js Applications](http://addyosmani.github.io/backbone-fundamentals/) // 2013.

ДЗ:

1. Реализовать проект на Backbone (определить models/collections и views).
2. Организовать подключение ресурсов через AMD.
3. Организовать сборку ресурсов для production и development окружения.

# 2 DOM & AJAX

## 2.1 Работа с DOM, Events

- [DOM](https://developer.mozilla.org/en/docs/DOM).
- [Events](http://www.w3.org/TR/DOM-Level-2-Events/events.html).
- [Событийно-ориентированное_программирование](http://ru.wikipedia.org/wiki/Событийно-ориентированное_программирование).
- [Host Objects](http://es5.github.io/#x4.3.8).

ДЗ:

1. Реализация игровой механики (на протяжении последующих домашних заданий в этом модуле).

## 2.2 Сетевое взаимодествие

- HTTP.
- AJAX.
- CORS.
- WebSockets.

Литература:

1. Tiffany Brown. [Introduction to XMLHttpRequest Level 2](http://dev.opera.com/articles/view/xhr2/) // 2012.
2. Armin Ronacher. [Websockets 101](http://lucumr.pocoo.org/2012/9/24/websockets-101/) // 2012.

ДЗ:

1. Наладить взаимодествие с сервером с помощью AJAX.

## 2.3 Хранение данных на клиенте

- Cookies.
- [Storage](http://www.html5rocks.com/en/features/storage).

ДЗ:

1. Организовать хранение пользовательских настроек на клиенте.
2. Сохранять результаты игры на клиенте, при остуствии связи с сервером.

# 3 Отладка и мобильный веб

## 3.1 Web Inspector и препроцессоры CSS

- [Sass](http://sass-lang.com).
- [Source Maps](https://developers.google.com/chrome-developer-tools/docs/css-preprocessors).

ДЗ:

1. Перевести CSS на Sass.

## 3.2 Производительность

- HTTP Cache.
- HTTP Waterfall.
- Reflow/Repaint.
- Web workers.
- [App Cache](http://www.html5rocks.com/en/tutorials/appcache/beginner/).
- Prefetching.
- CSS специфичность.

ДЗ:

1. Сделать прогресс-бар загрузки ресурсов.
2. Настроить HTTP заголовки, отвечающие за кеширование ресурсов.

## 3.3 Возможности смартфонов

- Акселерометр.
- Гироскоп.
- Тач-события.

Литература:

1. Chris Wilson, Paul Kinlan. [Touch And Mouse. Together Again For The First Time](http://www.html5rocks.com/en/mobile/touchandmouse/) // 2013.

ДЗ:

1. Сделать джойстик для смартфонов и организовать взаимодействие на websockets между экранами приложения.

# Полезные ссылки

1. [Build New Games. Open Web techniques for cutting-edge game development](http://buildnewgames.com).
