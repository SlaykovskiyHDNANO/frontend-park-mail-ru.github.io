# Преамбула

Предполагается, что студент имеет базовые знания веб-технологий (HTML, CSS, JavaScript) и практические навыки решения задач с помощью базовых алгоритмов и структур данных.

Проектная работа выполняется в группах по 2–3 человека (роли каждого должны быть представлены при формировании группы). Первое практическое занятие – индивидуальное.

Для выполнения проектной работы на занятиях потребуется ноутбук/виртуальная машина с установленной ОС Linux/OS X.

Ресурсы для самостоятельного изучения:

1. Влад Мержевич. [Самоучитель HTML4](http://htmlbook.ru/samhtml) // 2010.
2. Влад Мержевич. [Самоучитель CSS](http://htmlbook.ru/samcss) // 2010.
3. Илья Кантор. [Современный учебник JavaScript](http://learn.javascript.ru) // 2013.
4. Антон Шевчук. [jQuery для начинающих](http://anton.shevchuk.name/jquery-book/) // 2013.
5. [Mozilla Developer Network](https://developer.mozilla.org/).
6. [HTML5 Rocks](http://www.html5rocks.com/).
7. Mark Piligrim. [Dive into HTML5](http://diveintohtml5.info) // 2013.

# 1 Архитектура

## 1.1 Знакомство, инструменты, настройка окружения

#### Полезные ресурсы

1. Scott Chacon. [Pro Git](http://git-scm.com/book) // 2009.
2. [Grunt: Getting started](http://gruntjs.com/getting-started) // 2013.
3. Документация по [NPM](https://npmjs.org/doc/cli/npm.html) и [`package.json`](https://npmjs.org/doc/files/package.json.html).
4. Документация по шаблонизатору [Fest](https://github.com/mailru/fest).
5. Антон Шевчук. [jQuery для начинающих](http://anton.shevchuk.name/jquery-book/) // 2013.

### Лекция

Меня зовут Антон Епрев, в компании Mail.ru я руковожу группой фронтенд разработчиков проекта «Почта». Вести курс мне будут помогать мои коллеги: Егор Дыдыкин и Иван Чашкин. Егор руководит разработкой главной страницы Mail.ru и портальной навигацией, умеет делать такие веб-страницы, которые браузер быстро загружает и отрисовывает. Иван занимается разработкой веб-версии почты для смартфонов, знает если не абсолютно все, то безусловно очень много про особенности мобильных браузеров.

Курс фронтенд разработки состоит из трех модулей, восьми совмещенных занятий (на которых лекционная часть и практическая будут идти вместе), трех контрольных рубежей и презентации проекта. В общей сложности курс состоит из двенадцати занятий.

Обращаю ваше внимание, что на совмещенных занятиях будет вестись видеосъемка.

Сегодняшнее совмещенное занятие будет посвящено знакомству с курсом, инструментам и настройке рабочего окружения.

Дадим определение основных понятий.

Веб-приложение — клиент-серверное приложение, в котором клиентом выступает браузер, а сервером — веб-сервер. Логика веб-приложения распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, обмен информацией происходит по сети. Одним из преимуществ такого подхода является тот факт, что клиенты не зависят от конкретной операционной системы пользователя, поэтому веб-приложения являются межплатформенными сервисами [[Википедия](http://ru.wikipedia.org/wiki/Веб-приложение)].

Этот курс посвещен разработке той части веб-приложения, которая работает на стороне клиента – в браузере. От сюда и название – клиент-сайд. Другое название – front-end, тогда как часть веб-приложения, работающая на стороне сервера, называется back-end.

В результате изучения курса вы освоите современную разработку клиент-сайда веб-приложений; узнаете тонкости технологий HTTP, HTML 5, CSS 3, JavaScript, DOM, Events, Host Objects, AJAX; получите необходимую базу знаний о работе браузера (десктоп, смартфоны, планшеты), клиент-серверной архитектуре, архитектуре веб-приложений (события, модули, организации кода) и приобретёте  навыки работы с DOM, асинхронного и событийно-ориентированного программирования, сетевого взаимодествия (AJAX, WebSockets), организации многопоточности в браузере, использования CSS препроцессоров, отладки веб-приложений и сборки проекта с помощью Grunt для раскладки на сервер.

Для успешной сдачи курса необходимо самостоятельно реализовать клиен-сайд для однопользовательской игры с использованием смартфона в качестве игрового контроллера.

На протяжении всего семестра у вас будет три контрольных рубежа. Каждый рубежный контроль вместе с выполнением части проектной работы сопроваждается устным контроллем знаний. Прохождение первого контрольного рубежа дает возможность пройти второй рубеж, второго – третий. Программа предполагает своевременную сдачу каждого контрольного рубежа. Итоговый рейтинг по дисциплине представляет собой сумму баллов, полученных за прохождение рубежных контролей и домашних заданий. Для успешной аттестации по данному курсу студентам необходимо набрать пороговый рейтинг — 60 баллов. При пересчете баллов студенты могут получить итоговую оценку: 0–59 неудовлетворительно, 60–74 удовлетворительно, 75–89 хорошо, 90–100 отлично.

Каковы критерии оценки при прохождении рубежного контроля?

1. Соответствие результата предъявляемым требованиям.
2. Оптимальность предлагаемого решения.
3. Практичность решения (возможность дальнейшего применения в работе).
4. Качество оформления результатов работы.
5. Доказательность аргументации при защите работы.

Проектная работа ведется в группах по 2–3 человека (роли каждого должны быть представлены при формировании группы).

Вводная часть занятия окончена. Переходим в основной части.

Долгое время JavaScript был прерогативой клиент-сайда. Но с выходом [Node.js](http://nodejs.org) появилась возможность использовать JavaScript для написания высокопроизводительных приложений, исполняющихся на стороне сервера. С помощью языка программирования, которым владеет каждый фронтед разработчик, теперь стало возможным создавать различные инструметы, такие как системы сборки проекта, его тестирования и развертывания. Сегодня JavaScript является [самым популярным языком программирования](http://adambard.com/blog/top-github-languages-for-2013-so-far/) среди создаваемых на GitHub проектов.

Вместе с дистрибутивом Node.js распространяется и [NPM](https://npmjs.org) (Node Packaged Modules) — это менеджер пакетов для Node.js. У Java есть Maven, CPAN у Perl, а у Python есть pip, так и у разработчиков на Node.js есть NPM.

В качестве системы контроля верский кода мы будем использовать Git. Эту и следующие презентации вы сможете найти на [GitHub](https://github.com/eprev/frontend).

У каждого из вас уже имеется опыт разработки клиент-сайда, возможно, у кого-то этот опыт не ограничивается проектом, выполненным в прошлом семестре в рамках курса веб-технологий. И скорее всего, проект этот несложный. Такие проекты, обычно, состоят из одного-двух JavaScript файлов и CSS файла со стилями, которые браузер загружает по отдельности вместе с HTML кодом страницы. Такой подход перестает работать, когда проект начинает насчитывать тысячи строк кода JavaScript и стилей CSS. Работать с такими большими файлами неудобно, поэтому, как и в ситуации с программами, написанными на других языках программирования, прибегают к разбиению кода на модули, каждый из которых хранится в отдельном файле. Теперь для функционирования веб-приложения в браузере было бы необходимо загрузить десятки, а то и сотни, файлов JavaScript и CSS. Как вы должно быть уже знаете — это крайне неэффективно. Поэтому перед развертыванием проекта на сервере необходимо произвести его сборку: объединить множество JavaScript файлов в одну или несколько сборок, так же поступить и с CSS файлами, после чего эти сборки минифицировать. Минификация — это процесс сжатия исходного когда с сохранением его функциональности. Как правило, уменьшение размеры файлов достигается за счет удаления ненужных символов (таких как пробелы, переводы строк и комментарии) и замены имен переменных и функций на короткие варианты. На сегодняшний день самым популярным инструментом для сборки проектов является [Grunt](http://gruntjs.com/). Его без труда может установить каждый, воспользовавшись NPM.

Мы продолжаем двигаться от простых веб-приложений к сложным. Следующим этапом в веб-разработке становится Single Page Application — это веб-приложение, которое живет в браузере продолжительное время без березагрузки страницы. В таком приложении все дополнительные ресурсы загружаются по мере необходимости, а для отрисовки интерфейса используется клиентская шаблонизация. Существует огромное множество JavaScript шаблонизаторов, мы в компании разработали свой. [Fest](https://github.com/mailru/fest) обеспечивает высокую производительность и возможность использования шаблонов на стороне сервера. Например, главная страница Mail.ru формируется на стороне сервера с помощью скомпилированного в JavaScript код фестового шаблона.

### Практика

Создайте директорию для проекта.

```bash
$ mkdir ИМЯ-ПРОЕКТА
```

Создайте [`package.json`](https://npmjs.org/doc/files/package.json.html).

```bash
$ npm init
```

Установите Grunt и `grunt-contrib-connect`.

```bash
$ npm install grunt-cli -g
$ npm install grunt grunt-contrib-connect --save-dev
```

Создайте `Gruntfile.js` и настройте таск `connect`.

```javascript
module.exports = function (grunt) {

    grunt.initConfig({
        connect: {
            server: {
                options: {
                    keepalive: true, /* работать постоянно */
                    port: 8000, /* номер порта */
                    base: 'public' /* публичная директория */
                }
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-connect');

};
```

```bash
$ grunt connect
Running "connect:server" (connect) task
Waiting forever...
Started connect web server on http://localhost:8000
```

Создайте `public/index.html`.

Установите `grunt-fest` и настройте таск `fest`.

```bash
$ npm install grunt-fest --save-dev
```

```javascript
module.exports = function (grunt) {

    grunt.initConfig({
        connect: {
            server: {
                options: {
                    keepalive: true,
                    port: 8000,
                    base: 'public'
                }
            }
        },
        fest: {
            templates: {
                files: [{
                    expand: true,
                    cwd: 'templates', /* исходная директория */
                    src: '*.xml', /* имена шаблонов */
                    dest: 'public/js/tmpl' /* результирующая директория */
                }],
                options: {
                    template: function (data) { /* задаем формат функции-шаблона */
                        return grunt.template.process(
                            'var <%= name %>Tmpl = <%= contents %> ;', /* присваиваем функцию-шаблон переменной */
                            {data: data}
                        );
                    }
                }
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-connect');
    grunt.loadNpmTasks('grunt-fest');

};
```

Установите `grunt-contrib-watch` и настройте таск `watch`.

```javascript
module.exports = function (grunt) {

    grunt.initConfig({
        watch: {
            fest: {
                files: ['templates/*.xml'], /* следим за шаблонами */
                tasks: ['fest'], /* перекомпилировать */
                options: {
                    atBegin: true /* запустить задачу при старте */
                }
            }
        },
        connect: {
            server: {
                options: {
                    port: 8000,
                    base: 'public'
                }
            }
        },
        fest: {
            templates: {
                files: [{
                    expand: true,
                    cwd: 'templates',
                    src: '*.xml',
                    dest: 'public/js/tmpl'
                }],
                options: {
                    template: function (data) {
                        return grunt.template.process(
                            'var <%= name %>Tmpl = <%= contents %> ;',
                            {data: data}
                        );
                    }
                }
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.loadNpmTasks('grunt-contrib-connect');
    grunt.loadNpmTasks('grunt-fest');

    grunt.registerTask('default', ['connect', 'watch']); /* задача по умолчанию */

};
```

Добавьте [`livereload`](https://github.com/gruntjs/grunt-contrib-watch#optionslivereload).

```javascript
module.exports = function (grunt) {

    grunt.initConfig({
        watch: {
            fest: {
                files: ['templates/*.xml'],
                tasks: ['fest'],
                options: {
                    atBegin: true
                }
            },
            server: {
                files: [
                    'public/js/**/*.js', /* следим за статикой */
                    'public/css/**/*.css'
                ],
                options: {
                    interrupt: true,
                    livereload: true /* перезагрузить страницу */
                }
            }
        },
        connect: {
            server: {
                options: {
                    livereload: true, /* поддержка перезагрузки страницы */
                    port: 8000,
                    base: 'public'
                }
            }
        },
        fest: {
            templates: {
                files: [{
                    expand: true,
                    cwd: 'templates',
                    src: '*.xml',
                    dest: 'public/js/tmpl'
                }],
                options: {
                    template: function (data) {
                        return grunt.template.process(
                            'var <%= name %>Tmpl = <%= contents %> ;',
                            {data: data}
                        );
                    }
                }
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.loadNpmTasks('grunt-contrib-connect');
    grunt.loadNpmTasks('grunt-fest');

    grunt.registerTask('default', ['connect', 'watch']);

};
```

Подключите [jQuery](http://jquery.com). Создайте функции для отрисовки каждого из экранов игры.

```javascript
var $page = $('.page');

/* Конструктор экрана "Лучшие игроки" */
function showScoreboardScreen() {
    hideMainScreen();
}

/* Деструктор экрана "Лучшие игроки" */
function hideScoreboardScreen() {}

/* Конструктор экрана "Игра" */
function showGameScreen() {
    hideMainScreen();
}

/* Деструктор экрана "Игра" */
function hideGameScreen() {}

/* Конструктор экрана "Главный" */
function showMainScreen() {
    $page.html(mainTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-scoreboard').on('click', showScoreboardScreen);
    $page.find('.js-start-game').on('click', showGameScreen);
}

/* Деструктор экрана "Главный" */
function hideMainScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-scoreboard').off('click', showScoreboardScreen);
    $page.find('.js-start-game').off('click', showGameScreen);
}

showMainScreen();
```

Заключительный вариант.

```javascript
var $page = $('.page'),
    currentScreen = 'main';

/* Конструктор экрана "Лучшие игроки" */
function showScoreboardScreen() {
    hideMainScreen(); // Убиваем экран "Главный"
    currentScreen = 'scoreboard';
    $page.html(scoreboardTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-back').on('click', showMainScreen);
}

/* Деструктор экрана "Лучшие игроки" */
function hideScoreboardScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-back').off('click', showMainScreen);
}

/* Конструктор экрана "Игра" */
function showGameScreen() {
    hideMainScreen(); // Убиваем экран "Главный"
    currentScreen = 'game';
    $page.html(gameTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-back').on('click', showMainScreen);
}

/* Деструктор экрана "Игра" */
function hideGameScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-back').off('click', showMainScreen);
}

/* Конструктор экрана "Главный" */
function showMainScreen() {
     // Убиваем текущий экран
    if (currentScreen === 'scoreboard') {
        hideScoreboardScreen();
    } else if (currentScreen === 'game') {
        hideGameScreen();
    }
    currentScreen = 'main';
    $page.html(mainTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-scoreboard').on('click', showScoreboardScreen);
    $page.find('.js-start-game').on('click', showGameScreen);
}

/* Деструктор экрана "Главный" */
function hideMainScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-scoreboard').off('click', showScoreboardScreen);
    $page.find('.js-start-game').off('click', showGameScreen);
}

showMainScreen();
```

### Домашнее задание

1. Сформировать идею игры.
2. Определиться с группой и ролями в ней.
3. Создать прототип веб-приложения.

### Техническое задание

1. Прототип состоит из трех экранов:
    1. Главный экран (Main Screen). Содержит название игры и пункты главного меню:
        - Пункт «Лучшие игроки» ведет на экран «Лучшие игроки».
        - Пункт «Начать игру» ведет на основной экран игры.
    2. Лучшие игроки (Scoreboard Screen). Содержит название игры и кнопку «Назад», ведущую на главный экран.
    3. Основной экран игры (Game Screen). Содержит кнопку «Назад», ведущую на главный экран.
2. За отрисовку и последующую инициализацию каждого экрана должна отвечать отдельная функция в JavaScript.
3. При первой загрузке страницы с игрой появляется главный экран. Переход между экранами должен осуществлятся без перезагрузки страницы.
4. Для шаблонизации на строне клиента должен использоваться Fest (см. [`grunt-fest`](https://npmjs.org/package/grunt-fest) и [Fest](https://github.com/mailru/fest)).
5. На странице с игрой допускается загрузка одного JavaScript файла и одного CSS файла. Сборку этих файлов необходимо осуществить с помощью Grunt (см. [`grunt-contrib-concat`](http://npmjs.org/package/grunt-contrib-connect)).
6. С помощиью Grunt возможно запустить веб-сервер с игрой (см. [`grunt-contrib-connect`](https://npmjs.org/package/grunt-contrib-connect)). Страницу с игрой необходимо автоматически перезагружать при изменении исходных JavaScript, XML (Fest) или CSS файлов (см. параметр `livereload` в задачах `grunt-contrib-connect` и [`grunt-contrib-watch`](https://npmjs.org/package/grunt-contrib-watch)).

![Схема прототипа](/pics/prototype-scheme.png)

## 1.2 Архитектура веб-приложений

### Полезные ресурсы

1. Addy Osmani. [Patterns For Large-Scale JavaScript Application Architecture](http://addyosmani.com/largescalejavascript/) // 2011.
2. Эдди Османи. [Паттерны для масштабируемых JavaScript-приложений](http://largescalejs.ru) // 2011.
3. Addy Osmani. [Developing Backbone.js Applications](http://addyosmani.github.io/backbone-fundamentals/) // 2013.
4. Документация [Backbone.js](http://backbonejs.org).
5. Неофициальный перевод документации [Backbone.js](http://backbonejs.ru).
6. Документация [RequireJS](http://requirejs.org/).
7. Неофициальный перевод документации [RequireJS](http://requirejs.ru).
8. Документация [Underscore](http://underscorejs.org/).
9. Неофициальный перевод документации [Underscore](http://underscorejs.ru/).

### Лекция

Глобальные переменные в JavaScript доступны везде, локальные — только в области видимости, в которой они определены. Глобальные переменные являются свойствамии объекта `window`. Поэтому, объявляя глобальные переменные, вы рискуете изменить свойства `window`. Каждый раз при присвоении значения неопределенной локальной переменной, вы создаете или изменяете глобальную. Использование глобальных переменных является плохой практикой. В текущей спецификации JavaScript отсутствуют модули, которые бы разграничивали области видимости переменных, объявленых внутри. Но существуют несколько приемов, позволяющих реализовать модульность.

```javascript
var foo = 1;
(function (window, undefined) {
    var foo = 2;
    alert(foo); // 2
})(window);
alert(foo); // 1
```

Конструкция в примере выше называется *немедленно-вызываемая функция* (Immediately-Invoked Function Expression, IIFE). Мы создаем анонимную функцию и незамедлительно вызываем ее, с параметрами или без.

Пока что наша функция ничего не возвращает, и модулем назвать ее сложно. Рассмотрим пример по сложнее.

```javascript
var foo = 1;
var module = (function (window, undefined) {
        var foo = 2; // приватная переменная
        return {
            say: function () { // публичный метод
                alert(foo); // 2
            }
        };
    })(window);
alert(foo); // 1
```

На этот раз немедленно-вызываемая функция возвращает объект, определяющий интерфейс модуля, с которым уже можно работать в других частях веб-приложения. Такой подход предотвращает попадание приватных переменных и функций в глобальный контекст, где они могут конфликтовать с другими интерфейсами.

В отличии от некоторых других языков программирования, JavaScript не поддерживает модификаторы доступа. Область видимости ограничивает доступность объявленных в ней переменных. Таким образом, объявленные внутри модуля переменные и функции доступны только изнутри этого модуля, а свойства объекта, возвращаемого модулем, будут доступны всем.

При разработке сервер-сайда веб-приложения популярен подход [MVC](http://ru.wikipedia.org/wiki/Model-View-Controller) (Model-View-Controller). Обработкой запроса к серверу занимается контроллер (Controller). Контроллер обращается за данными к модели (Model), которая общается с базой данных. Полученые от модели данные контроллер отправлят в представление (View) для формирования ответа на поступивший запрос.

![MVC сервер-сайда](/pics/mvc-ss.png)

Так вот, при разработке клиент-сайда больших веб-приложения тоже применяется подход MVC, но в действительности он работает по-другому. Во главе теперь стоит модель. При изменении своего состояния модель оповещает об этом всех слушателей. Представление это интерфейс, то что видит пользователь и с чем работает. Представлет следит за изменения модели и реагирует на них. Но когда пользователь взаимодействует с представлением (например, выполнилняет click по кнопке), представление передает управление контроллеру. Последний в свою очередь вносит изменения в модель и все начинается сначала.

![MVC клиент-сайда](/pics/mvc-cs.png)

Как устроен клиент-сайд сложного веб-приложения?

Уровень библиотек.
Уровень ядра приложения.
Уровень модулей.

> Модуль — функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом… предназначенный для использования в других программах [[Википедия](http://ru.wikipedia.org/wiki/Модуль_(программирование\))].

Модуль веб-приложения состоит из HTML, CSS и JavaScript. Модули характеризуются [связанностью](http://ru.wikipedia.org/wiki/Связанность_(программирование\)). Слабая связанность позволяет вносить изменения в один модуль не оказывая при этом влияния на остальные.

Давайте посмотрим на одно из популярный веб-приложений — «Почту».

![Почта](/pics/email.png)

Веб-приложение состоит из многих модулей, вот некоторые из них.

Портальное меню (`portal-menu`).
![Модуль Портальное меню](/pics/email-portal-menu.png)

Тулбар (`toolbar`).
![Модуль Тулбар](/pics/email-toolbar.png)
![Модуль Тулбар](/pics/email-toolbar-2.png)

Навигация (`nav`).
![Модуль Навигация](/pics/email-nav.png)

Список писем (`letters`).
![Модуль Список писем](/pics/email-datalist.png)

Чтобы модули обладали слабой связанностью не только на уровне логическом (JavaScript), но и на уровне представления (CSS), мы в разработке придерживаемся методологии [БЭМ](http://ru.bem.info/).

Что такое БЭМ?

БЭМ расшифровывается как «Блок, Элемент, Модификатор». Это методология разработки веб-проектов, способ удобно делить интерфейс на отдельные блоки и элементы.

Модуль – это блок в терминологии БЭМ. Блок состоит из элементов или других блоков. Например блок `toolbar`, который показан на рисунках выше, состоит из элементов – кнопок `toolbar__button`.

Кнопка тулбара (`toolbar__button`).
![Элемент toolbar__button](/pics/email-toolbar__button.png)

Согласно БЭМ, в имени элемента обязательно должно присутствовать имя блока, которому он принадлежит, и для их разрграничения обычно используется два нижних подчеркивания. Сделано это для того, чтобы минимизировать количество контекстных селекторов при описании стилей блоков и элементов. Зачем это необходимо?

В качестве примера рассмотрим простейший пример реализации кнопки в тулбаре.

```html
<div class="toolbar">
    <div class="button">Click Me</div>
</div>
```

```css
.toolbar .button {
    background: white;
}
```

А теперь поместим этот тулбар в окошко, в котором тоже есть кнопки, но другие.

```html
<div class="window">
    <div class="toolbar">
        <div class="button">Click Me</div>
    </div>
    <button class="button">Submit</button>
</div>
```

```css
.toolbar .button {
    background: white;
}
.window .button {
    background: black;
}
```

Обе кнопки в примере выше будут черного цвета. Цвет кнопки внутри `toolbar` оказался перебит значением, заданным по умолчанию для кнопок внутри блока `window`. Мы оказались в ситуации, когда визуальное оформление элемента `button` блока `toolbar`, зависит от окружения, в которое помещен блок. БЭМ позволяет свести такие ситуации к нулю. За счет отказа от использования контекстных селекторов, мы достигаем практически нулевой связности между блоками, блоки становятся независимыми от того окружения, в котором они окажутся.

```html
<div class="window">
    <div class="toolbar">
        <div class="toolbar__button">Click Me</div>
    </div>
    <button class="window__button">Submit</button>
</div>
```

```css
.toolbar__button {
    background: white;
}
.window__button {
    background: black;
}
```

Теперь элементы `toolbar__button` и `window__button` являются абсолютно независимыми. У таког подхода ко всему прочему есть еще один приятный момент — скорость отрисовки страниц. Чем сложнее селектор в каскадной таблице стилей, тем браузеру дольше находить стили для элементов страницы.

Одни и теже блоки и элементы не всегда выгледят одинаково в итерфейсе. Например, они могут отличаться геометрическими размерами или отличаться графическим содержанием (как это бывает с иконками у тех же самых кнопок). Для этих целей в БЭМ предусмотрены модификаторы. Модификатор это класс, который применяется дополнительно к блоку или элементы с целью изменения его представления. В имени модификатора обязательно присутствует имя блока или элемента, который он изменяет, а для разграничения используется один символ нижнего подчеркивания. Например, `toolbar_fixed` (модификатор `fixed` блока `toolbar`) или `toolbar__button_size_xl` (модификатор `size` в значении `xl` элемента `button` блока `toolbar`).

Веб-приложение представляем собой результат работы модулей из которых оно состоит.

Когда модули слабо связаны между собой, то удаление одного, не приведет к некорректной работе остальные модули. Поэтому, модули не должны напрямую обращаться к методам других модулей, вместо этого модули отправляют и принимают собщения. Это частный случай событийно-ориентированного программрования, который применяется при разработки пользовательских интерфейсов.

Ядро веб-приложения отвечает за управление модулями (загрузка, инициализация и освобождение ресурсов), предоставляет средства коммуникации между модулями и занимается обработкой ошибок в приложении.

На уровне библиотек находятся инструменты для работы с DOM, AJAX, парсеры и т.п.

При разработке проектной работы мы будем использовать довольно популярный стек технологий:

1. Уровень библиотек: jQuery и [Underscore](http://underscorejs.org/).
2. Уровень приложения: [Backbone](http://backbonejs.org/).
3. Уровень моделуй: [AMD](https://github.com/amdjs/amdjs-api/wiki/AMD) и [RequireJS](http://requirejs.org/).

Underscore это библиотека для манипулирования данными в функциональном стиле. Без этой библиотеки не обойтись при использовании Backbone. Существует более быстрая реализация Underscore – [Lo-Dash](http://lodash.com/). При желании, можете использовать ее в своей проектной работе.

Мы уже видели как можно создавать модули в JavaScript с помощью анонимных функций. Теперь когда мы умеем разбивать сложное веб-приложение на модули, то становится актуальной проблема управления зависимостями между модулями. Например, для работы контроллера «Списка писем» необходимы модули с реализацией моделей письма и коллекции писем, а так же модуль работы с представлением списка писем.

Мы рассмотрим, пожалуй, самый популярный механиз определения модулей и их зависимостей в JavaScript. Речь идет о AMD (Asynchronous Module Definition). 

Вернемся к примеру с простейшей реализацией модуля в JavaScript.

```javascript
var A = (function () {
        var name = 'A'; // приватная переменная
        return {
            say: function () { // публичный метод
                alert(name);
            }
        };
    })();
```

В AMD этот модуль следует определить следующим образом:

```javascript
define('A', function () {
    var name = 'A'; // приватная переменная
    return {
        say: function () { // публичный метод
            alert(name);
        }
    };
});
```

А следующая запись определяет модуль `B`, который зависит от модуля `A`.

```javascript
define('B', ['A'], function (A) {
    var name = 'B'; // приватная переменная
    return {
        say: function () { // публичный метод
            A.say(); // обращение к публичному методу модуля A
            alert(name);
        }
    };
});
```

Интерфейсы зависимых модулей передаются в качестве параметров в функцию-конструктор определяемого модуля. AMD это не библиотека, это спецификация, и функция `define` не определена в JavaScript. Для загрузки модулей, определенных с помощью механизма AMD, используется RequireJS.

Теперь разберемся с ядром веб-приложения. Оно построено будет с использованием Backbone.

Backbone состоит из моделей (models), коллекций (collections) и представлений (views). Как вы заметили, контроллеры отсутсвуют в Backbone. Представления в Backbone, в отличие от MVC, знают что делать при взаимодействии пользователя с ними.

### Домашнее задание

1. Доработка прототипа по техническому заданию.

### Техническое задание

1. Прототип визуально не изменяется.
2. Подключить [`RequireJS`](http://requirejs.org/) к проекту.
    1. Описать [`require.config`](http://requirejs.org/docs/api.html#config) в файле `main.js`, указать зависимость [`Backbone.js`](http://backbonejs.org/) от [`jQuery`](http://jquery.com/) и [`Underscore.js`](http://underscorejs.org/)
    2. Точкой входа приложения является `main.js` который подключает [Backbone.Router](http://backbonejs.org/#Router) - `router.js`
3. Для каждого экрана нужно создать свою [Backbone.View](http://backbonejs.org/#View)
    1. Главный экран (Main Screen) - `views/index.js`
    2. Лучшие игроки (Scoreboard Screen) - `views/scoreboard.js`
    3. Основной экран игры (Game Screen) - `views/game.js`
4. Для Scoreboard Screen необходимо реализовать [Backbone.Collection](http://backbonejs.org/#Collection) и [Backbone.Model](http://backbonejs.org/#Model) - `collections/scores.js` и `models/score.js`
5. Структура связей:
```
main.js
    router.js
        views/toolbar.js
            fest/toolbar.js
        views/index.js
            fest/index.js
        views/game.js
            fest/game.js
        views/scoreboard.js
            fest/scoreboard.js
            collections/scores.js
            models/score.js
```
6. Структура файлов (dev):
```
public/
    js/
        main.js
        router.js
        fest/
            index.js
            game.js
            scoreboard.js
            toolbar.js
        views/
            index.js
            game.js
            scoreborad.js
            toolbar.js
        collections/
            scores.js
        models/
            score.js
        libs/
            jquery.js
            backbone.js
            underscore.js
            almond.js
            require.js
```
7. Сборка проекта
    1. В `Gruntfile.js` таск `default` собирает продакшен версию, таск `fest` собирает шаблоны, `scss` собирает css, `watch` следит за `public/css/\*\*/\*.scss` и `public/js/fest/\*\*/\*.xml`
    2. JavaScript проекта собирается в 2 файла `production/js/libs.js` (`jquery.js`, `backbone.js`, `underscore.js` и `almond.js`) и `production/js/main.js`
    3. CSS проекта собирается в файл `public/css/main.css`
8. Запуск проекта
    1. Запуск в режиме dev `$ node app.js`

# 2 DOM & AJAX

## 2.1 Работа с DOM, Events

- [DOM](https://developer.mozilla.org/en/docs/DOM).
- [Events](http://www.w3.org/TR/DOM-Level-2-Events/events.html).
- [Событийно-ориентированное_программирование](http://ru.wikipedia.org/wiki/Событийно-ориентированное_программирование).
- [Host Objects](http://es5.github.io/#x4.3.8).

ДЗ:

1. Реализация игровой механики (на протяжении последующих домашних заданий в этом модуле).
2. Сделать форму ввода имени игрока после окончания игры.
2. Релазиовать PubSub:
    1. RulleyView подписывается на showScreen и скрывает остальные экраны.
    2. Бросить gaveOver, на который показывать ввод имени игрока. А после ввода, должна показывать скрин списка игроков.

## 2.2 Сетевое взаимодествие

- HTTP.
- AJAX.
- CORS.
- WebSockets.

### Серверное RESTful API для работы со Score

1. GET /scores
	1. Код 200 - возвращает всю коллкцию scores или первые x элементов (заданные через ?limit=x) отсортированную по убыванию счета игрока
2. GET /scores/:id
	1. Код 200 - возвращает модель с переданным id
	2. Код 400 - не верные входные данные
	3. Код 404 - модель с указанным id не найдена
3. POST /scores
	1. Request Body: {"name": "<name>", "score": <score>}
	2. Код 200 - возвращает id созданной модели
	3. Код 400 - не верные входные данные
4. DEL /scores/:id
	1. Код 200 - удаляет модель с переданным id
	2. Код 400 - не верные входные данные
	3. Код 404 - модель с указанным id не найдена
5. PUT /scores/:id
	1. Request Body: {"id": <id>, "name": "<name>", "score": <score>}
	2. Код 200 - обновляет и возвращает модель с переданным id
	3. Код 400 - не верные входные данные
	4. Код 404 - модель с указанным id не найдена

### Техническое задание

1. Создать новый view GameOver на экране Game
	1. View должна содержать поле ввода имени игрока, кнопку сохранения и отображать переданный при инициализации счет игрока.
	2. При сабмите формы создается модель score с указанными в форме данными и добавляется в коллекцию scores
	3. Модель сохраняется на сервер.
	4. На время сохранения форма блокируется
	5. При ошибке сохранения пользователю выводится ошибка и форма разблокируется
	6. После успешного сохранения форма разблокируется, сбрасывается и происходит переход на экран Scoreboard
2. Модифицировать экран Scoreboard для получения данных с сервера (топ 10)
	1. При отображении экрана происходит fetch коллекции scores
	2. Во время загрузки пользователю отображается сообщение о загрузке
	3. В случае ошибки загрузки пользователю отображается соответствующее сообщение с возможностью обновить экран
	4. В случае успешной загрузки отображается список

Литература:

1. Tiffany Brown. [Introduction to XMLHttpRequest Level 2](http://dev.opera.com/articles/view/xhr2/) // 2012.
2. Armin Ronacher. [Websockets 101](http://lucumr.pocoo.org/2012/9/24/websockets-101/) // 2012.
3. [HTTP Status Codes](http://www.restapitutorial.com/httpstatuscodes.html).

ДЗ:

1. Наладить взаимодествие с сервером с помощью AJAX.

## 2.3 Хранение данных на клиенте

- Cookies.
- [Storage](http://www.html5rocks.com/en/features/storage).

ДЗ:

1. Организовать хранение пользовательских настроек на клиенте.
2. Сохранять результаты игры на клиенте, при остуствии связи с сервером.

# 3 Отладка и мобильный веб

## 3.1 Web Inspector и препроцессоры CSS

- [Sass](http://sass-lang.com).
- [Source Maps](https://developers.google.com/chrome-developer-tools/docs/css-preprocessors).

ДЗ:

1. Перевести CSS на Sass.

## 3.2 Производительность

### Полезные ресурсы

1. Yahoo Developer Network. [Best Practices for Speeding Up Your Web Site](http://developer.yahoo.com/performance/rules.html).

### Лекция

- HTTP Cache.
- HTTP Waterfall.
- Reflow/Repaint.
- Web workers.
- [App Cache](http://www.html5rocks.com/en/tutorials/appcache/beginner/).
- Prefetching.
- CSS специфичность.

### Домашнее задание

1. Организовать сборку ресурсов для production и development окружения.

### Техническое задание
1. Структура файлов (production):
```
production/
    js/
        libs.js
        main.js
    css/
        main.css
```
2. CSS проекта собирается с флагом  `style: 'compressed'` в файл `production/css/main.css`
3. Сборка main.js осуществляется с помощью [`grunt-contrib-requirejs`](https://npmjs.org/package/grunt-contrib-requirejs)).
4. Минификация файла осуществялется с помощью [`grunt-contrib-uglify`](https://npmjs.org/package/grunt-contrib-uglify).
5. В продакшене для реализации AMD используется [`almond`](https://github.com/jrburke/almond).
6. Запуск production `$ NODE_ENV=production node app.js`
7. Определение в `node.js` текущей версии `process.env.NODE_ENV == 'production'`
```JavaScript
if( process.env.NODE_ENV == 'production' ){
    app.use(express.static(path.join(__dirname, 'production')));
}else{
    app.use(express.static(path.join(__dirname, 'public')));
}
```

ДЗ:

1. Сделать прогресс-бар загрузки ресурсов.
2. Настроить HTTP заголовки, отвечающие за кеширование ресурсов.

## 3.3 Возможности смартфонов

- Акселерометр.
- Гироскоп.
- Тач-события.

### RPC API

Создаем экземпляр Connector с указанием remote: '/<тип клиента: console|player>'.
```JavaScript
var server = new Connector({
	remote: '/console'
});
```
Через socket.io устанавливается соединение с сервером по пути, указанному в remote, и происходит запрос на получение набора функций, поддерживаемых сервером. Запрос асинхронный, потому Connector предоставляет метод onReady, позволяющий начать работу с сервером, когда все будет готово.
```JavaScript
server.onReady(function(){
	server.someServerSideFunction();
});
```
При желании можно часть или все функции объявить при инициализации и вызывать их сразу. Запросы на вызов серверной функции складываются в очередь и будут запущены после полчения списка серверных функций.
```JavaScript
var server = new Connector({
	server: ['getToken', 'bind'],
	remote: '/console'
});

server.getToken(function(token){});
```

На сервере реализованы следующие функции:
```JavaScript
server.getToken(function(token){
	token // токен для иниализации связи
});

// для первичной инициализации связки по токену
server.bind({token: '<token>'}, function(data){
	data.status // 'success' в случае успеха, 'undefined token' в случае ошибки, 'busy token' в случае, если токен занят
	data.guid // guid связки в случае успеха
});

// для восстановления связки, когда guid уже получен
server.bind({guid: '<guid>'}, function(data){
	data.status // 'success' в случае успеха, 'undefined guid' в случае ошибки
});
```

Так же Connector поддерживает следующие события
```JavaScript
server.on('connect', function(){}); // установка соединения
server.on('disconnect', function(){}); // потеря соединения
server.on('reconnect', function(){}); // восстановление соединения
```

Специальное событие для консоли, происходящее когда игрок подключил джойстик
```JavaScript
server.on('player-joined', function(data){
	data.guid // guid инициализированной связки
});
```

Для общения между консолью и джойстиком используется метод send для отправки сообщения от одного клиента и событие message на другом для получения сообщения.
```JavaScript
server.send(data, function(answer){
	answer // ответ другой стороны
});

server.on('message', function(data, answer){
	data // данные сообщения
	answer('<answer>') // отправка ответа обратно
});
```

Литература:

1. Chris Wilson, Paul Kinlan. [Touch And Mouse. Together Again For The First Time](http://www.html5rocks.com/en/mobile/touchandmouse/) // 2013.

ДЗ:

1. Сделать джойстик для смартфонов и организовать взаимодействие на websockets между экранами приложения.

# Полезные ссылки

1. [Build New Games. Open Web techniques for cutting-edge game development](http://buildnewgames.com).
