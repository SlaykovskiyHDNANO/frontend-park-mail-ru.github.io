---
layout: default
title: HTML формы, авторизация, регистрация, AJAX
---

{::options auto_ids="false" /}

[ГЛАВНАЯ](/)

Формы:
{: id="1"}

1.1 [Введение. Веб формы. Назначение и основные определения.](#1.1)

1.1.1 [Введение](#1.1.1)\\
1.1.2 [Веб формы](#1.1.2)\\
1.1.3 [Назначение и основные определения](#1.1.3)
{:.toc}

1.2 [HTML верстка. Элементы форм. Атрибуты формы и ее элементов.](#1.2)

1.2.1 [HTML верстка](#1.2.1)\\
1.2.2 [Элементы форм](#1.2.2)\\
1.2.3 [Атрибуты формы и ее элементов](#1.2.3)
{:.toc}

1.3 [Работа с формами на JavaScript. События формы и ее элементов. Работа с данными формы. Валидация данных формы.](#1.3)

1.3.1 [Работа с формами на JavaScript](#1.3.1)\\
1.3.2 [События формы и ее элементов](#1.3.2)\\
1.3.3 [Валидация данных формы](#1.3.3)
{:.toc}

1.4 [Передача данных на сервер. Рендер новой страницы. Отправка в iframe. AJAX. Обработка результатов.](#1.4)

1.4.1 [Передача данных на сервер](#1.4.1)\\
1.4.2 [Рендер новой страницы](#1.4.2)\\
1.4.3 [Отправка в iframe](#1.4.3)\\
1.4.4 [AJAX](#1.4.4)\\
1.4.5 [Обработка результатов](#1.4.5)
{:.toc}

1.5 [UX решения в формах. Возможности HTML5. Дополнительный материал для самостоятельного изучения.](#1.4)

1.5.1 [UX решения в формах](#1.5.1)\\
1.5.2 [Дополнительный материал](#1.5.2)
{:.toc}

## 1.1 Введение. Веб формы. Назначение и основные определения.
{: id="1.1"}

### 1.1.1 Введение
{: id="1.1.1"}


Всем привет! Сегодня у нас первое лекционное занятие, которое будет посвящено вопросам передачи пользовательских данных на сервер и представлению результатов обработки этих данных пользователю. Если коротко, то мы поговорим о таком широко известном и распространенном элементе интерфейса веб-приложения, как веб-форма. Любому мало-мальски знакомому с вебом человеку такой выбор темы может показаться странным именно в виду распространенности и обыденности форм. Однако, практика показывает, что многие веб-разработчики не знают всех особенностей этого механизма, либо плохо себе представляют его современные возможности. Итак, о чем же мы сегодня будем говорить?

 Как вы можете видеть, нас ждет 5 небольших модулей. В первую очередь мы немножко поговорим о применении форм и дадим основные определения. Далее познакомимся с необходимой нам HTML разметкой, узнаем о том, какие базовые возможности интерфейса форм доступны нам без применения JavaScript. Далее посмотрим, что можно делать с формами с помощью JavaScript. После этого узнаем, как можно обеспечить корректность данных, вводимых пользователем. Логичным шагом после подготовки внешнего вида и валидности данных будет создание механизма, передающего эти данные на сервер и предоставление результатов обработки пользователю. В конце лекции мы постараемся понять, что можно сделать, чтобы упростить жизнь рядового пользователя при работе с формами. Если останется время, мы поговорим о возможностях современных браузеров.


### 1.1.2 Веб формы
{: id="1.1.2"}

Итак, давайте формализуем понятие формы и разберемся, где нам пригодится такой элемент интерфейса. У классической формы есть только одно предназначение - это передача данных на сервер. И на сегодняшний день формы - это единственный кроссбраузреный инструмент, служащий этой цели. Многие из вас могут мне возразить, что можно и нужно использовать AJAX для этих целей. Да это так, если речь идет лишь о текстовых данных. Если нам необходимо передать на сервер файл (будь то текстовый документ или изображение, не так важно), мы не обойдемся без формы. Существуют и другие способы передать на сервер файл, но они либо не будут работать в некоторых современных браузера (речь идет о Flash и продуктах компании Apple), либо в старых версиях IE до сих пор широко распространенных в сети и нуждающихся в поддержке (XHR2, FileAPI). В современных веб-приложениях широко используюется частичное использование элементов форм. Любые поля, заполняемые пользователем с клавиатуры - это части формы. Формы - это удобный и очень хорошо знакомый пользователям элемент интерфейса. Очень сложно привести пример приложения, в котором мы бы не смогли найти хотя бы одну форму или ее элемент.

### 1.1.3 Назначение и основные определения
{: id="1.1.3"}

В спецификации HTML5 мы можем найти следующее определение формы:

>A form is a component of a Web page that has form controls, such as text fields, buttons, checkboxes, range controls, or color pickers. A user can interact with such a form, providing data that can then be sent to the server for further processing (e.g. returning the results of a search or calculation).

Фактически то же самое по-русски и проще для нас формулирует Википедия.

>Форма (англ. form) в HTML — раздел документа, позволяющий пользователю вводить информацию для последующей обработки системой. Синтаксически форма в HTML задаётся с помощью элемента form и в дополнение к разметке обычных элементов содержит разметку для элементов управления(англ. controls), надписей (англ. label) и других.

Не сложно заметить, что в спецификации HTML5 в определении фигурируют новые и пока еще не очень распространенные элементы форм: range controls, or color pickers. О них мы поговорим чуть позже, а пока рассмотрим несколько вариантов классических форм, использующихся в большинстве веб-приложения.

## 1.2 HTML верстка. Элементы форм. Атрибуты формы и ее элементов.
{: id="1.2"}

### 1.2.1 HTML верстка
{: id="1.2.1"}

Мы здесь пытаемся разобраться во фронтенд разработке. Как театр начинается с вешалки, так и фронтенд начинается с верстки. Сверстаем нашу форму!

Любая форма начинается с тега form, внутри которого располагаются все остальные элементы. Причем, внутри формы могут находиться не только элементы формы, но и любые другие элементы страницы, кроме еще одной формы. Вложенность форм не допускается. Итак, создадим самую простую форму, с помощью которой можно, например, заказать пиццу:

~~~
<form>
 <p><label>Имя пользователя: <input></label></p>
</form>
~~~
{:.html}

### 1.2.2 Элементы форм
{: id="1.2.2"}

На что здесь можно сразу обратить внимание? Во-первых на то, что пиццу мы пока заказать не можем, но к этому мы обязательно придем. Во-вторых, что мы сразу использовали два наиболее популярных элемента формы: input и label. Input - это самый популярный контрол любой формы. Если не указано дополнительных атрибутов, он выглядит как обычное текстовое поле. Label - это описание этого поля. В принципе, можно использовать для этих целей любой другой HTML элемент, но у label есть замечательная особенность. Если мы свяжем label и input с помощью атрибутов id и for, то все браузеры будут ставить фокус в поле при клике по соответствующему лэйблу. Это бывает очень удобно.

~~~
<form>
 <p>
<label for=”name”>Customer name: <input id=”name”></label>
 </p>
</form>
~~~
{:.html}


Добавим еще несколько элементов и кратко поговорим об их назначении.

~~~
<form>
 <p><label>Customer name: <input></label></p>
 <p><label>Telephone: <input type=tel></label></p>
 <p><label>E-mail address: <input type=email></label></p>
 <p><label>Order type: <select>
                          <option>Business</option>
                          <option>Customer</option>
                  </select>
    </label>
</p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size> Small </label></p>
  <p><label> <input type=radio name=size> Medium </label></p>
  <p><label> <input type=radio name=size> Large </label></p>
 </fieldset>
 <fieldset>
  <legend> Pizza Toppings </legend>
  <p><label> <input type=checkbox> Bacon </label></p>
  <p><label> <input type=checkbox> Extra Cheese </label></p>
  <p><label> <input type=checkbox> Onion </label></p>
  <p><label> <input type=checkbox> Mushroom </label></p>
 </fieldset>

 <p><label>Delivery instructions: <textarea></textarea></label></p>
 <p><button>Submit order</button></p>
</form>
~~~
{:.html}

Посмотрим, что нового мы добавили в форму и как это новое будет себя вести. Во-первых, обратите внимание, что мы добавили несколько input и указали им атрибут type со значениями checkbox и radio. И хотя об атрибутах элементов форм мы поговорим отдельно, этот случай рассмотрим сейчас. Этот атрибут кардинально меняет поведение input, который только что представлял собой обычное текстовое поле. Именно таким образом мы можем создать радиокнопки и чекбоксы. Разница между этими элементами в том, что для одного значения поля радиокнопки предоставляют лишь один вариант значения  — именно поэтому у всех трех инпутов такого типа проставлен одинаковый атрибут name, т.е. с точки зрения пользователя набор радиокнопок представляется одним полем, для которого можно выбрать значение из заранее подготовленного списка. Каждый же из чекбоксов представляет собой отдельное поле, значение которого пользователь может отметить как выбранное.

Появилось поле, определяющие тип заказа - Order type. У радиокнопок есть отличная альтернатива для случаем, когда вариантов больше 3, или если необходима возможность выбрать сразу несколько вариантов. Тег <select> позволяет создать элемент интерфейса в виде раскрывающегося списка, а также список с одним или множественным выбором, как показано далее. Конечный вид зависит от использования атрибута size тега <select>, который устанавливает высоту списка. Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Каждый пункт создается с помощью тега <option>, который должен быть вложен в контейнер <select>.  Чтобы сделать список, с возможностью выбора нескольких варианов, необходима к тегу select добавить атрибут multiple.

Три радиокнопки находятся внутри элемента fieldset. Этот элемент предназначен для группирования элементов формы. Такая группировка облегчает работу с формами, содержащими большое число данных. Например, один блок может быть предназначен для ввода текстовой информации, а другой — для флажков. Чтобы объяснить пользователю назначение того или иного блока предусмотрен элемент legend. В некотором смысле legend - это аналог label для одиночного поля. Интересной особенностью блока fieldset является то, что с его помощью можно разносить элементы форм в разные места HTML страницы. Для этого служит атрибут form, в котором можно указать идентификатор нужной формы. Этот случай исключение из правила, что все элементы формы должны располагаться внутри тега form.

Для дополнительной информации, которую пользователь посчитает необходимым передать в службу доставки мы создали специальный элемент textarea. Его поведение аналогично обычному input, с той лишь разницей, что в браузере textarea будет выглядеть как поле с несколькими строками. Такой элемент используется в том случае, если мы заранее не уверены, какую именно информацию пользователю понадобиться передать на сервер. Обычно, допустимым значение textarea является любой текст.

В нижней части нашей формы мы разместили кнопку - элемент button. Этот элемент служит для инициализации отправки данных на сервер, или, как говорят, submit формы. В принципе, вместо button можно использовать и уже известный нам элемент input, у которого будет выставлен атрибут type со значением submit. Но, в отличие от этого тега, <button> предлагает расширенные возможности по созданию кнопок. Например, на подобной кнопке можно размещать любые элементы HTML, в том числе изображения. Используя стили можно определить вид кнопки путем изменения шрифта, цвета фона, размеров и любых других параметров.

По большому счету теперь у нас есть все базовые элементы формы, необходимые для отправки данных о заказе на сервер:

1. Текстовые поля - input[type=text], textarea
2. Радиокнопки - input[type=radio]
3. Флажки или чекбоксы - input[type=checkbox]
4. Выпадающие списки - select и options
5. Кнопки, управляющие формой - input[type=submit][type=reset], button[type=submit][type=reset]

Прежде чем попытаться заказать нашу пиццу давайте подробнее поговорим про атрибуты элементов форм и их назначение. Забегая вперед скажу, что пиццу мы не получим с той формой, что есть у нас сейчас и без атрибутов никак не обойдемся.

### 1.2.3 Атрибуты формы и ее элементов.
{: id="1.2.3"}

Модифицируем нашу форму еще раз.

~~~
<form method="post"
      enctype="application/x-www-form-urlencoded"
      action="https://pizza.example.com/order.cgi">
 <p><label>Customer name: <input name="custname"></label></p>
 <p><label>Telephone: <input type=tel name="custtel"></label></p>
 <p><label>E-mail address: <input type=email name="custemail"></label></p>
<p><label>Order type: <select name="custtype">
                          <option value="Business">Business</option>
                          <option value="Customer">Customer</option>
                  </select>
    </label>
</p>
 <fieldset>
  <legend> Pizza Size </legend>
  <p><label> <input type=radio name=size value="small"> Small </label></p>
  <p><label> <input type=radio name=size value="medium"> Medium </label></p>
  <p><label> <input type=radio name=size value="large"> Large </label></p>
 </fieldset>
 <fieldset>
  <legend> Pizza Toppings </legend>
  <p><label> <input type=checkbox name="topping" value="bacon"> Bacon </label></p>
  <p><label> <input type=checkbox name="topping" value="cheese"> Extra Cheese </label></p>
  <p><label> <input type=checkbox name="topping" value="onion"> Onion </label></p>
  <p><label> <input type=checkbox name="topping" value="mushroom"> Mushroom </label></p>
 </fieldset>
 <p><label>Preferred delivery time: <input type=time min="11:00" max="21:00" step="900" name="delivery"></label></p>
 <p><label>Delivery instructions: <textarea name="comments"></textarea></label></p>
 <p><button>Submit order</button></p>
</form>
~~~
{:.html}


 Атрибуты у элементов созданы для того, чтобы изменять и конкретизировать поведение этих элементов. У всех элементов есть стандартное поведение, которое проявляется без использование атрибутов. Например, button или input. Однако, в абсолютном большинстве случаев, стандартного поведения недостаточно. Разберемся, какие изменения мы внесли в форму.

Во-первых, мы установили для самого элемента формы три новых атрибута. method=”post”. Таким образом мы сообщаем браузеру о методе HTTP, в котором необходимо совершить запрос на сервер после отправки формы. Доступны два значения этого атрибута:

GET - этот метод является одним из самых распространенных и предназначен для получения требуемой информации и передачи данных в адресной строке. Пары «имя=значение» присоединяются в этом случае к адресу после вопросительного знака и разделяются между собой амперсандом (символ &). Удобство использования метода get заключается в том, что адрес со всеми параметрами можно использовать неоднократно, сохранив его, например, в закладки браузера, а также менять значения параметров прямо в адресной строке.

POST - метод post посылает на сервер данные в запросе браузера. Это позволяет отправлять большее количество данных, чем доступно методу get, поскольку у него установлено ограничение в 4 Кб. Большие объемы данных используются в форумах, почтовых службах, заполнении базы данных, при пересылке файлов и др.

enctype - Определяет способ кодирования данных формы при их отправке на сервер. Обычно устанавливать значение атрибута enctype не требуется, данные вполне правильно понимаются на стороне сервера. Но, в случае, если вы планируете отправлять на сервер файлы, его наличие обязательно. Существует несколько допустимых значений. Подробнее о них, как и о других атрибутах и их значениях можно прочитать на htmlbook.ru

action -  указывает обработчик, к которому обращаются данные формы при их отправке на сервер. Если атрибут action отсутствует, текущая страница перезагружается, возвращая все элементы формы к их значениям по умолчанию. Значением именно этого атрибута мы и связываем клиентскую и серверную сторону нашего приложения. Подробнее о вариантах отправки данных формы на сервер мы поговорим отдельно.
Однако помимо модификации самой формы, мы изменили атрибуты ее элементов. Основным изменение является добавление пар name и value ко всем элементов, данные которых должны оказаться в службе доставки. Именно эти пары значения и будут передаваться на сервер после отправки формы.

В заключении этого раздела я хотел бы обратить ваше внимание на несколько необычную конструкцию атрибутов, указанных для поля delivery. Здесь я позволю себе забежать немного вперед и рассказать о преимуществах, которые дает нам использование HTML5. Набором атрибутов type=time min="11:00" max="21:00" step="900"  для элемента input мы в современных браузерах сделали из обычного текстового поля сделали элемент, позволяющий задавать интервалы времени. При этом не написав ни строчки на JavaScript! В самом конце нашей лекции мы поговорим о HTML5 в формах о том какие возможности доступны уже сейчас, какие из них можно безопасно использовать, а на какие пока что просто интересно посмотреть.

Фактически, мы получили рабочую во всех актуальных браузерах, валидную с точки зрения HTML5 форму! Хочу только отметить, что в рамках нашей сегодняшней лекции мы говорим лишь о малой части тех возможностей, что предоставляют браузеры для работы с формами. Однако, этот тот базис, который позволит вам организовать работу с данными пользователя в вашем веб-приложении. А сейчас поговорим о том, как данные форм можно передавать на сервер.


## 1.3 Работа с формами на JavaScript. События формы и ее элементов. Работа с данными формы. Валидация данных формы.
{: id="1.3"}

### 1.3.1 Работа с формами на JavaScript
{: id="1.3.1"}


Рассмотрим основные элементы формы и средства для работы с ними. В проекте вы используете библиотеку jQuery, поэтому помимо кода на чистом JavaScript я буду приводить код jQuery.
input, textarea
Для большинства типов input значение доступно на чтение-запись в value:

~~~
var input = document.getElementById(‘input’),
textarea = document.getElementById(‘textarea’);


/*Устанавливаем новые значения для полей*/
input.value = "значение";
textarea.value = "текст";

$(input).val(‘значение jQuery’);
$(textarea).val(‘значение jQuery’);
~~~
{:.javascript}

Это самое простое и в то же время самое распространенное действие, которое обычно приходится производить над формами. Стоит обратить внимание на элемент textarea. В разметке он выглядит как обычный тег, но не стоит для него делать исключение и пользоваться свойством innerHTML, чтобы получить или установить значение такого поля формы. Оно хранит только HTML, изначально присутствовавший в элементе. Кроме того, оно не преобразует HTML-entities.

input type="checkbox", input type="radio"

Для этих элементов можно узнать или установить текущее «отмеченное» состояние.
Оно находится в свойстве checked (true/false).

~~~
if (input.checked) {
  alert("Чекбокс выбран");
}
~~~
{:.javascript}

Обратите внимание на разницу значения атрибута и свойства. Атрибут имеет значение «как указано в HTML», а свойство — логическое, в соответствие со стандартом.

~~~
<input type="checkbox" id="input" checked>

<script>
	var input = document.getElementById('input');
	console.log(input.checked); // true
	console.log(input.getAttribute('checked')); // пустая строка
</script>
~~~
{:.html}

Как некоторые из вас могут знать, у jQuery для аналогичных целей существуют так же два метода: prop и attr. prop используется для работы со свойствами, а attr для атрибутов.

~~~
<input id="input" type="checkbox" checked>

<script>
	console.log($('#input').attr('checked')); // 'checked'
	console.log($('#input').prop('checked')); // true
</script>
~~~
{:.html}

select, option
Элементы типа select, как и input, поддерживают свойство value.
Он обычно возвращает значение (value) выбранной опции, ну а в случае <select multiple> — значение первой из них.

~~~
var selectedOptionValue = select.value;
~~~
{:.javascript}

Элемент селекта в JavaScript можно выбрать двумя путями: поставив значение select.value, либо установив свойство select.selectedIndex:

~~~
select.selectedIndex = 0; // первый элемент
~~~
{:.javascript}

Установка selectedIndex = -1 очистит выбор.
Опции доступны через select.options.
Если select допускает множественный выбор (атрибут multiple), то значения можно получить/установить, сделав цикл по select.options:

~~~
<form id="form" name="form">
  <select name="genre" multiple>
    <option value="blues" selected>Мягкий блюз</option>
    <option value="rock" selected>Жёсткий рок</option>
    <option value="classic">Классика</option>
  </select>
</form>
<script>
var form = document.getElementById(‘form’);
var select = form.elements.genre;
for (var i=0; i<select.options.length; i++) {
  var option = select.options[i];
  if(option.selected) {
    console.log(option.value);
  }
}
</script>
~~~
{:.html}


### 1.3.2 События формы и ее элементов.
{: id="1.3.2"}
В этой теме есть смысл отступить от правила, согласно которому мы пробуем разобраться в нативном JS коде, а после этого посмотреть на jQuery реализацию. Причиной этому служит разнообразие всевозможных событий и их поведений в различных браузерах. Поэтому, посмотрим на события с точки зрения рядового разработчика. Для примера будем использовать самый распространенный элемент: input[type=”text”].

[jsfiddle](http://jsfiddle.net/z70arqnk/)


### 1.3.3 Валидация данных формы.
{: id="1.3.3"}


Что такое и зачем нужна валидация:
1. Защита пользователя от ошибок
2. Снижение нагрузки на сервер
3. Консистентность базы

Регулярные выражения
>Регулярные выражения (англ. regular expressions) — формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов (символов-джокеров, англ. wildcard characters). По сути это строка-образец (англ. pattern, по-русски её часто называют «шаблоном», «маской»), состоящая из символов и метасимволов и задающая правило поиска.

html5 валидация

~~~
<input type="text" name="name" required>
<input type="email" …>
~~~
{:.html}

Почему валидация на клиенте не отменяет валидацию на сервере
JavaScript выполняется на клиенте и может быть отключен.


Проверка выполняется в зависимости от задачи:
1. Во время ввода (oninput)
2. Перед вводом (onfocus)
3. По окончании ввода (onblur)
4. Перед отправкой формы (onsubmit)
5. В случае выявленной ошибки пользователю нужно сообщить и тут есть несколько вариантов:
6. Выделение поля с ошибкой
7. Поясняющее текстовое сообщение об ошибке
8. Фокус на поле ввода с ошибкой
9. Блокировка кнопки для отправки формы

## 1.4 Передача данных на сервер. Рендер новой страницы. Отправка в iframe. AJAX. Обработка результатов.
{: id="1.4"}

### 1.4.1 Передача данных на сервер
{: id="1.4.1"}

В целом, существует три способа, передачи данных формы на сторону сервера:
1. Сабмит формы с ренедером новой страницы в новом или текущем окне
2. Сабмит формы в iframe
3. Сериализация данных формы и передача данных с помощью технологии AJAX

Первых два из них представляют собой одно и то же с точки зрения серверной стороны, но имеют различные реализации на стороне клиента. Поэтому, мы будем рассматривать их независимо друг от друга. Перед тем как мы рассмотрим каждый из способов в отдельности, поговорим немного о самом процессе и общих особенностях для всех трех случаев.
Перед тем как осуществлять какую-то передачу данных было бы здорово подготовить к этому сервер. Про организацию кода и написание обработчика данных на стороне backend вы очевидно уже знаете из смежного курса Java. Фронтенд-разработчик должен знать всего несколько вещей о сервере при работе с формами: адрес HTTP endpoint, метод HTTP, который необходимо использовать и способ кодирования данных в форме, который ожидает от него сервер. Если вы помнить мы только что рассмотрели три необходимых атрибута у тега form, однозначно определяющих эти понятия. Вызывающим наибольшее количество вопросов мне представляется выбор значения атрибута method.

Обычно к методу GET прибегают для передачи на сервер небольшого количества текстовых данных или простого набора параметров(отписаться от рассылки, потдвердить прочтение лицензионного соглашения и т.п.). Обратите ваше внимание на кэширование. GET запросы кэшируются и это очень часто вызывает определенные проблемы при разработке. Избежать кэширования запроса можно путем добавления произвольного параметра к нему. Чаще всего для этих целей используется текущее значение timestamp или случайное число. Преимуществами этого метода являетя возможность использование URL запроса в дальнейшем. Например, для размещения каких-то данных в социальных сетях.

Собственно из этих соображений вытекают преимущества и недостатки метода POST. Этот метод используется для передачи на сервер больших массивов текста, файлов, приватных данных. Использование антикэш параметров в этом методе необязательно. Такие запросы НЕ кэшируются. Здесь стоит заметить, что правильно сказать ОБЫЧНО не кэшируются или ПО СПЕЦИФИКАЦИИ не кэшируются. Есть интересное исклчение - iOS6. В этой ОС POST запрос может не добраться до вашего сервера, если это покажется нецелесообразным парням из Купертино. Проверяйте ваши формы, следите за кроссбраузерностью ваших решений. А в данном случае, если вам придется столкнуться с такой проблемой, просто используете дополнительный случайный параметр в форме по аналогии с GET антикеш параметром.


### 1.4.2 Рендер новой страницы
{: id="1.4.2"}

Итак, перейдем к первому способу отправки формы. Он самый старый и, как следствие, самый простой с точки зрения клиентской реализации. Его использование вообще не требует знаний JavaScript! Мы будем рендерить новую страницу после отправки данных на сервер. Пример, который мы разбирали в предыдущем модуле ведет себя именно так. 

~~~
<form method="post"
      enctype="application/x-www-form-urlencoded"
      action="https://pizza.example.com/order.cgi"> 
…
</form>
~~~
{:.html}

С точки зрения фронтенд разработки здесь сложно что-то добавить. После отправки данных сервер должен отренедерить новый или тот же шаблон, в зависимости от результатов, полученных при обработке данных. Этот способ уже почти ушел в прошлое. Неудобство его использование налицо - при каждой отправки формы нам нужно перерисовывать всю страницу целиком. Что можно сделать? Самое простое - открыть результаты, полученные от сервера в новом окне. Для этих целей воспользуемся еще одним атрибутом у тега form - target.

~~~
<form method="post"
      enctype="application/x-www-form-urlencoded"
      action="https://pizza.example.com/order.cgi"
      target="_blank"> 
…
</form>
~~~
{:.html}

Значением _blank у этого атрибута мы указываем браузеру на то, что надо открыть новую страницу и загрузить результаты обработки формы в ней. Поведение полностью аналогично такому же атрибуту у ссылки. Однако, способ все равно еще попахивает лихими девяностыми и снежинками на страничке. Современный пользователь уже не ждет, что результат обработки формы будет представлен ему в новой вкладке браузера. Особенно этого не ждет пользователь мобильный. Что можно сделать, чтобы выправить ситуацию?


### 1.4.3 Отправка в iframe
{: id="1.4.3"}

Этот способ не сильно моложе и сложнее предыдущего, но при этом обеспечивает несколько существенных преимуществ как с точки зрения разработчика, так и пользователя. Заключается он в том, что вместе с формой на странице необходимо разместить специальный iframe, в котором и будет загружен результат обработки формы. Понятно, что в современном вебе видимый фрем на странице(если это не рекламный баннер) будет смотреться достаточно странно и архаично.  Поэтому, мы сделаем этот фрейм невидимым и пометим его идентификатором и атрибутом name. В форме же укажем соответсвующее значение уже знакомому нам атрибуту target.

~~~
<form method="post"
      enctype="application/x-www-form-urlencoded"
      action="https://pizza.example.com/order.cgi"
      target="transport"> 
…
</form>
…
<iframe frameborder="0" name="transport" id="transport" class="hidden-frame"></iframe>
~~~
{:.html}

Теперь при загрузке с сервера результатов обработки формы, они будут помещены в этот iframe. При этом основная страница не будет перезагружена, а ее история останется неизменной! Остается только одна проблема, как “извлечь” данные результата и показать их пользователю. Здесь мы начнем действовать динамически, JavaScript позволяет нам это сделать. Чтобы передать информацию из фрейма в основную страницу у нас есть два способа: использовать HTML5 функциональность PostMessage или же получить доступ к контексту родительского фрейма и вызвать заранее объявленную функцию с набором параметров. В первом случае, вам необходимо загрузить в iframe код на подобии следующего:

~~~
<body>
        <script>
            var msg = {
                name: 'auth.user',
                data: {
"info": {
"name": "Artem", 
"email": "artem@gmail.com"
},
"status": "OK"
}
            };

            window.parent.postMessage(JSON.stringify(msg), '*');
        </script>
</body>
~~~
{:.html}


А в JS коде основной страницы расположить обработчик события postMessage.

~~~
$(window).on("message", postMessageDispatcher);
~~~
{:.javascript}

После загрузки результатов обработки сервером формы будет вызвана функция postMessageDispatcher с набором параметров из фрейма, о содержании этой функции вам предстоит позаботиться самостоятельно. Хочу лишь отметить, что вы должны предусмотреть обработку как успешного завершения обработки данных, так и всевозможные ошибки, но об этом чуть позже. Какие есть особенности у postMessage? О кроссбраузерности решения можно почти не беспокоится. InternetExplorer поддерживает эту технологию начиная с 8 версии. Почему почти? Потому что IE поддерживает только передачу строк в качестве тела сообщения. Именно для этого в скрипте, расположенном в iframe используется JSON сериализация данных. Одним из основных плюсов данного подхода является кроссдоменность решения.
Есть еще один способ оповестить родительское окно о том, что наш сервер что-то слелал после отправки ему формы. Разница лишь в коде, располагающемся во фрейме.

~~~
<body>
    <script type="text/javascript">
            window.parent.successSend(true);
    </script>
</body>
~~~
{:.html}

Если наш фрейм находится на том же домене, что и основное окно, мы можем получить доступ к JS контексту родителя. Функция successSend должна выполнить те же действия, что и postMessageDispatcher.

### 1.4.4 AJAX
{: id="1.4.4"}

У предыдущего способа есть один существенный недостаток - наличие iframe. Нам приходится создавать еще один HTML элемент, отдельно думать о его рендеринге, создавать отдельный шаблон на сервере для форматирования данных, полученных от сервера, заводить уникальные идентификаторы и действовать в глобальном контексте JS. Мало того, мы сильно ограничены в возможности контроля над HTTP запросом. У frame существует только одно событие - load, а это значит, что мы не можем отслеживать ошибки соединения и оповещать о них пользователя.  Все это выглядит громоздко и негибко. Решение по сути на поверхности и многие из вас уже наверняка поняли, о чем же сейчас пойдет речь. О технологии AJAX, которая в корне изменила подходы в клиентском веб-программировании и открыла для нас широчайший спектр возможностей в создании веб-приложений. С ее приходом в веб,  фронтенд разработка фактически перестала зависеть от разработки серверной части. Теперь мы можем договариваться с backend программистами лишь о пересылаемых данных и их формате. У вас будет отдельная лекция, посвященная этой теме, а в рамках этой мы рассмотрим лишь небольшой пример использования AJAX. По своей сути AJAX - это возможность сделать запрос к серверу без перезагрузки основной страницы с использованием JavaSctipt. Именно этим мы сейчас и займемся.

Ваше приложение вы разрабатываете с использованием фреймворка Backbone, использование которого подразумевает(хоть и не обязывает) использовать библиотеку jQuery. Поэтому, дальнейший рассказ об AJAX я буду вести в терминах jQuery. Вспомним, что форма - это лишь набор данных в формате “ключ”-”значение”. Ключом является содержание атрибута name у элемента формы, а значением - содержание value. Соответственно, чтобы реализовать ее AJAX отправку на сервер достаточно собрать эти пары, организовать их с использованием какого-нибудь правила и передать на сервер. В качестве такого правила чаще всего использовать JSON - JavaScript Object Notation, хотя, вам никто не запрещает воспользоваться XML нотацией. Фактически все эти действия в состоянии выполнить за нас jQuery.


~~~
$("#idForm").on("submit", function(event) {
    var url = "path/to/your/script";
    event.preventDefautlt();

    $.ajax({
           type: "POST",
           url: url,
           data: $(this).serialize(),
           success: function(data)
           {
               postDispatcher(data);
           }
         });
});
~~~
{:.javascript}

Попробуем разобраться, что мы только что сделали. Фактически весь блок кода, который вы видите на экране представляет собой вызов одной функции - $.ajax, с одним аргументом - объектом настроек. Ничего сверхъестественного. С его помощью мы делаем один запрос к серверу. Проведем аналогию с обычной отправкой формы браузером. Можно представить, что $.ajax - это и есть наша форма, а все, что внутри - содержимое формы, или, если проводить параллель с предыдущими способами - атрибуты и элементы формы. 
type: "POST" -  полный аналог атрибуты формы type=”post”, определяет тип HTTP запроса.
url: "path/to/your/script" - аналог атрибута action=”path/to/your/script”, определяет серверный ресурс, отвечающий за обработку данных
data: $(this).serialize() - аналог элементов формы, имеющих атрибуты name и value. В этом месте разберемся чуть-чуть подробнее. Мы видим, что в значение поля data мы записываем результат выполнения метода serialize некого объекта $(this). Пока что я просто предлагаю вам поверить, что $(this) - это и есть наша форма, а serialize - один из ее методов. Этот методи собирает данные о всех полях формы и формирует из них объект, состоящий из пар “ключ”-”значение”. Тот самый объект, о котором я говорил в начале этого модуля. Т.е., если внутри формы есть несколько инпутов

~~~
<input name=”firstName” value=”Ivan” />
<input name=”secondName” value=”Susanin” />
~~~
{:.html}

то в наш объект с данными будет выглядеть так:

~~~
{
	“firstName”: “Ivan”,
	“secondName”: “Susanin”
}
~~~
{:.javascript}

Все предельно просто. Процесс превращения формы в такой объект и называют сериализацией формы. Остался последний параметр:
success: function(data){ postDispatcher(data);} - этой строчкой мы задаем обработчик, который сработает после успешной отправки формы. В примере, посвященному сабмиту формы в iframe аналогичная функция называлась postMessageDispatcher. На самом деле, метод $.ajax имеет много других интересных опций. С ними вы обязательно познакомитесь самостоятельно!
Осталось только разобраться, когда же будет инициализирован запрос на сервер, т.е. вызван $.ajax. Логичным кажется сделать это клику пользователя на конпку, отправки формы, однако это не является по-настоящему хорошей практикой. Вспомните, большинство форм в вебе можно отправить не только с помощью клика по кнопке, но и по нажатию Enter на клавиатуре. Вместо того, чтобы следить за двумя событиями (клик и нажатие Enter), можно следить лишь за одним - отправкой формы. Браузер дает разработчику возможность следить за событиями элементов страницы. В том числе за событиями форм. У вас будет лекция, посвященная этой теме. А пока мы остановимся только на одном, очень важном для нас событии, submit. Оно возникает при отправке формы, вне зависимости от способа, которым эта отправка инициирована. По событию submit мы делаем две вещи: во-первых, запрещаем браузеру отправлять форму на сервер стандартными средствами или, иначе говоря, прерываем стандартное действие браузера. Это действие осуществляет вызов  event.preventDefautlt(); и во-вторых, осуществляем отправку AJAX запроса на сервер - вызываем $.ajax.



### 1.4.5 Обработка результатов
{: id="1.4.5"}

+ Несколько рекомендаций по написанию функций, отвечающих за обработку результатов после отправки формы.

+ Всегда помните, что возможны несколько различных результатов обработки и не все из них будут успешными.

+ Если по каким-то причинам сервер сообщает, что обработать данные формы не удалось, нужно сообщить об этом пользователю в приемлемой форме. Если вы знаете, какие поля, вызывали проблемы на сервере, обязательно подсветите их в интерфейсе.

+ Сделайте защиту от многократной отправки формы. Многие начинающие пользователи по привычке используют двойной клик.

+ Если процесс обработки данных занимает значительное время, предусмотрите прелоудер и блокировку фомы от повторного сабмита.

+ Если вы отправляет форму с помощью AJAX, не забывайте остановить стандартную отправку формы браузером.


## 1.5 UX решения в формах. Возможности HTML5. Дополнительный материал для самостоятельного изучения.
{: id="1.5"}

### 1.5.1 UX решения в формах
{: id="1.5.1"}

Подразумевается, что в своем проекте вы должны реализовать функциональность создания и редактирования учетных записей пользователей, а так же обеспечивать процедуру их аутентификации. Обычно для этих целей служат три формы: форма регистрации, форма входа и форма редактирования личных данных пользователя.

Авторизация.
Большинство интерфейсов веб-приложений состоит как минимум из двух частей: публичной и приватной; или же поведение интерфейса имеет две основных парадигмы с соответствующими названиями. Первую видят все пользователи, вторую только авторизованные. Следовательно, чаще всего, в первой части располагается общая информация о приложении, рассказывается о том, какие функции оно выполняет и для чего служит. Вторя же часть - приватная, чаще всего персонифицирована под конкретного пользователя. Не вызывает сомнений, что, например в Почте, мы обязаны обеспечить приватность писем пользователя или дать возможность сохранять настройки внешнего вида интерфейса вне зависимости от используемого устройства. Границей, разделяющей эти две части является форма авторизации.

Если приложение, которое вы разрабатываете не подразумевает возможность работы без авторизации пользователя, то может оказаться так, что форма авторизации будет первое, что увидят ваши пользователи.

Форма авторизации является точкой входа и, как следствие, очень существенно влияет на формирование впечатления о приложении в целом. Не стоит перегружать эту форму дополнительными полями. Вполне достаточным будет организация полей идентификатора пользователя и пароля. Отличным решением является возможность авторизации с помощью существующих учетных записей в популярных сервисах(авторизация через социальные сети). Если вы решили реализовать такую возможность, подойдите крайне ответственно к выбору этих сервисов. Возможность авторизоваться с помощью учетной записи GitHub в интернет-магазине косметики выглядит по меньшей мере странно. Учитывайте географические и поло-возрастные особенности вашей аудитории.

Уже на этом этапе бывает полезно задуматься о безопасности. Здесь есть две основных проблемы: сохранение приватности передаваемых данных и опасность взлома учетных записей пользователей путем перебора пароля. По поводу первой проблемы хочется отметить, что хорошим тоном является передача всех личных данных пользователя с использованием шифрованного соединения с помощью протокола HTTPS. Даже если у вас нет технической возможности обеспечить работу всего приложения по HTTPS, это не помешает сделать несколько https endpoint для авторизации, регистрации и работы личного кабинета. Возникающие проблемы с кросс-доменными ограничениями браузеров можно решить без особых затруднений, но об этом чуть позже.

Не забывайте так же максимально усложнить жизнь злоумышленникам. Предусмотрите в вашем интерфейсе авторизации использование капчи после нескольких неудачных попыток и используйте CSRF (англ. Сross Site Request Forgery — «Межсайтовая подделка запроса», также известен как XSRF) токены. Если капчу видели все пользователи Интернет, то про CSRF стоит сказать несколько слов дополнительно. Поддержка CSRF токенов есть в большинстве современных серверных фреймворков. Если коротко, то необходимо предусмотреть скрытый input в форме, значением которого будет некий хэш, генерируемый сервером при загрузке страницы. Авторизовать пользователя можно только тогда, когда значение этого хэша при отправке формы на сервер соответствует его значению при загрузке. Вы просто убеждаетесь в том, что форму отправил именно тот пользователь, который загрузил страницу с ней.

Регистрация.

В последние несколько лет появилась тенденция использования в качестве точки входа не форму логина, а страницу регистрации. Такое решение кажется вполне логичным для молодых приложений, которым еще только предстоит завоевать мир.

Уверен, что о необходимых полях при регистрации вы сможете подумать самостоятельно. Дам лишь несколько советов. Чем меньше полей вы заставите заполнить пользователя, тем больше шанс, что у него хватит терпения пройти этот квест до конца и начать наслаждаться вашим приложением.

Не заставляйте лишний раз повторять уже введенные данные. Например, вместо дублирования поля пароль можно дать возможность увидеть, что скрывается за звездочками в этом поле.

Обязательно отмечайте поля, которые действительно необходимо заполнить для успешного завершения процесса регистрации. Это могут быть звездочки или выделенные болдом лэйблы полей и очень яркая подсветка не заполненных обязательных полей при попытке отправки формы.

Для получения данных о дате рождения или телефоне обязательно используйте сложные элементы формы. Нельзя заставлять пользователей вводить дату рождения в удобном для вас формате, не обеспечив при этом удобство этого процесса.

Если для даты рождения удачным решением выглядит группа обычных селектов, то для телефонного номера можно использовать плагин, форматирующий данные в поле по мере его заполнения. Так называемые маски и обязательный пример заполнения двусмысленных полей, телефон привычно начинать с +7, 7, 8 или вовсе без префикса.

Обязательно объясняйте пользователю ошибки, если они возникают. Подсвечивайте поле, в котором произошла ошибка, рядом выводите текст ошибки. Очень плохой практикой является использование в качестве текста ошибки фраза на подобии “поле заполнено некорректно. Пожалуйста, заполните данное поле корректно”. Ставьте фокус в ошибочное поле.

Если есть возможность, сразу же после регистрации обеспечивайте доступ пользователя к функциональности приложения. Не заставляйте его еще раз вводить пару логин/пароль, которую он только что уже вводил.

Стоит так же сказать несколько слов о безопасности форм регистрации. У всех популярных сервисов есть проблема, связанная с кибер-сквоттерами и массовыми регистрациями учетных записей. Если вы посмотрите в инспекторе форму регистрации нашей Почты, вы можете обратить внимание на то, что атрибуты name у ключевых полей представляют собой хэши, генерируемые при загрузке. Это исключает использование совсем простых способов создания множества аккаунтов. При регистрации пользователя необходимости в идентификации пользователя формы как человека значительно выше, чем при авторизации. Для этого используют привязку к социальным сетям, номеру телефона или простую капчу. Безусловно, все эти меры не являются обязательными и чаще всего делают интерфейс более громоздким и неудобным, но чаще всего на них приходится идти ради безопасности.

Существует один очень простой прием, позволяющий отсечь львиную долю регистраций с помощью ботов. Он называется honey pot - медовое пятнышко. Идея состоит в том, что большинство ботов действует в полностью автоматическом режиме и заполняют поля заранее подготовленными данными в соответствии с их названиями. Этот прием отлично срабатывает на формах обратной связи или в формах добавления комментария. Реализация крайне проста - создайте в верстке невидимый инпут с “красивым”, с точки зрения робота именем. Например, email или phone. Его верстка должна полностью соответствовать верстке обычного поля с той лишь разницей, что это поле будет скрыто средствами CSS. На сервере же предусмотрите простое условие, по которому не выполняйте предусмотренное действие, если это поле окажется заполненным. Большинство ботов не рендерят страницу целиком, а просто ищут в ней форму и заполняют поля. Работ “наступит” в вашу медовую лужицу и уже больше никогда из нее не выберется. Не забудьте только отрендерить сообщение об успешной отправки формы в таком случае!

Редактирование личных данных.

В заключении модуля коротко поговорим про Личный кабинет пользователя в вашем приложении. По большому счету, его функциональность обычно совпадает с формой регистрации с учетом некоторых особенностей. Я бы выделил две основные: интеграция с функциональностью авторизации через социальные сервисы и вопросы безопасности. Если вы даете возможность авторизоваться с помощью учетной записи стороннего сервиса, не забудьте предусмотреть возможность объединения такой учетной записи с записью, созданной более традиционными методами. Т.е. дайте пользователю возможность ввести пароль, который можно будет использовать только в вашем приложении. Или изменить данные, полученные вами из записи в социальных сетях. Если вы делаете игру, далеко не всегда юзерам будет хотеться называться так же, как и в учетной записи Facebook или использовать ту же аватарку. Это достаточно сложная задача, но ее реализация чаще всего того стоит.

В вопросах же безопасности следуют некоторые упрощения по сравнению с формой регистрации. Обычно, можно ограничится только защищенным соединением HTTPS.


### 1.5.2 Дополнительный материал для самостоятельного изучения
{: id="1.5.2"}

1. [Все, что можно сказать про формы с точки зрения HTML, сказано здесь](http://htmlbook.ru/samhtml5/formy)
2. [Спецификация HTML5 в изложении для разработчиков](http://developers.whatwg.org/forms.html#forms)
3. [JavaScript для работы с формами](http://learn.javascript.ru/forms-methods)
4. [Старый и мощный формовый движок](http://zforms.ru/)
5. [Новый формовый движок на основе BackboneJS](https://github.com/powmedia/backbone-forms)
