<!DOCTYPE  html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=792, user-scalable=no">
        <title>Markdown</title>
        <style>
            body {
                margin: 0;
                padding: 26px;
                font-family: Segoe, "Segoe UI", Candara, Calibri, Arial, sans-serif;
                font-size: 18px;
                line-height: 26px
            }
            section {
                max-width: 768px;
                margin: auto;
            }
            h1, h2, h3, h4, h5, h6 {
                margin: 0 0 26px;
                text-rendering: optimizeLegibility;
                page-break-inside: avoid;
                font-weight: 400
            }

            h1 {
                font-size: 36px;
                line-height: 52px;
                text-transform: uppercase
            }

            h2 {
                font-size: 32px
            }

            h2, h3 {
                line-height: 52px
            }

            h3 {
                font-size: 27px
            }

            h4 {
                font-size: 24px;
                line-height: 26px
            }

            h5 {
                font-size: 21px
            }

            h5, h6 {
                line-height: 26px
            }

            h6 {
                font-size: 18px
            }

            ul, ol, pre, blockquote {
                margin: 26px 0
            }

            blockquote {
                font-style: italic;
                border-left: 4px solid #d6d6d6;
                padding-left: 1em
            }

            ul {
                list-style-position: outside
            }

            p {
                margin: 26px 0;
                -webkit-hyphens: auto;
                -moz-hyphens: auto;
                -ms-hyphens: auto;
                -o-hyphens: auto;
                hyphens: auto
            }

            code {
                font-family: "Courier New", Courier, monospace;
                font-size: 18px;
                line-height: 1
            }

            abbr {
                letter-spacing: .1em
            }

            a {
                text-decoration: none;
                border-bottom: 1px solid #555
            }

            img {
                max-width: 100%;
            }

            /**
             *  github.com style (c) Vasily Polovnyov <vast@whiteants.net>
             */
            pre code {
                display: block; padding: 26px;
                color: #333;
                background: #f8f8ff;
                overflow: auto;
            }
            pre .comment,
            pre .template_comment,
            pre .diff .header,
            pre .javadoc {
                color: #998;
                font-style: italic
            }
            pre .keyword,
            pre .css .rule .keyword,
            pre .winutils,
            pre .javascript .title,
            pre .nginx .title,
            pre .subst,
            pre .request,
            pre .status {
                color: #333;
                font-weight: bold
            }
            pre .number,
            pre .hexcolor,
            pre .ruby .constant {
                color: #099;
            }
            pre .string,
            pre .tag .value,
            pre .phpdoc,
            pre .tex .formula {
                color: #d14
            }
            pre .title,
            pre .id {
                color: #900;
                font-weight: bold
            }
            pre .javascript .title,
            pre .lisp .title,
            pre .clojure .title,
            pre .subst {
                font-weight: normal
            }
            pre .class .title,
            pre .haskell .type,
            pre .vhdl .literal,
            pre .tex .command {
                color: #458;
                font-weight: bold
            }
            pre .tag,
            pre .tag .title,
            pre .rules .property,
            pre .django .tag .keyword {
                color: #000080;
                font-weight: normal
            }
            pre .attribute,
            pre .variable,
            pre .lisp .body {
                color: #008080
            }
            pre .regexp {
                color: #009926
            }
            pre .class {
                color: #458;
                font-weight: bold
            }
            pre .symbol,
            pre .ruby .symbol .string,
            pre .lisp .keyword,
            pre .tex .special,
            pre .prompt {
                color: #990073
            }
            pre .built_in,
            pre .lisp .title,
            pre .clojure .built_in {
                color: #0086b3
            }
            pre .preprocessor,
            pre .pi,
            pre .doctype,
            pre .shebang,
            pre .cdata {
                color: #999;
                font-weight: bold
            }
            pre .deletion {
                background: #fdd
            }
            pre .addition {
                background: #dfd
            }
            pre .diff .change {
                background: #0086b3
            }
            pre .chunk {
                color: #aaa
            }
        </style>
    </head>
    <body>
        <section>
            <h1 id="-">Преамбула</h1>
<p>Предполагается, что студент имеет базовые знания веб-технологий (HTML, CSS, JavaScript) и практические навыки решения задач с помощью базовых алгоритмов и структур данных.</p>
<p>Проектная работа выполняется в группах по 2–3 человека (роли каждого должны быть представлены при формировании группы). Первое практическое занятие – индивидуальное.</p>
<p>Для выполнения проектной работы на занятиях потребуется ноутбук/виртуальная машина с установленной ОС Linux/OS X. Из программного обеспечения — <a href="http://git-scm.com">Git</a> и <a href="http://nodejs.org">Node.js</a>.</p>
<p>Ресурсы для самостоятельного изучения:</p>
<ol>
<li>Влад Мержевич. <a href="http://htmlbook.ru/samhtml">Самоучитель HTML4</a> // 2010.</li>
<li>Влад Мержевич. <a href="http://htmlbook.ru/samcss">Самоучитель CSS</a> // 2010.</li>
<li>Илья Кантор. <a href="http://learn.javascript.ru">Современный учебник JavaScript</a> // 2013.</li>
<li>Антон Шевчук. <a href="http://anton.shevchuk.name/jquery-book/">jQuery для начинающих</a> // 2013.</li>
<li><a href="https://developer.mozilla.org/">Mozilla Developer Network</a>.</li>
<li><a href="http://www.html5rocks.com/">HTML5 Rocks</a>.</li>
<li>Mark Piligrim. <a href="http://diveintohtml5.info">Dive into HTML5</a> // 2013.</li>
<li><a href="http://devdocs.io">DevDocs</a>.</li>
</ol>
<h1 id="1-">1 Архитектура</h1>
<h2 id="1-1-">1.1 Знакомство, инструменты, настройка окружения</h2>
<h4 id="-">Полезные ресурсы</h4>
<ol>
<li>Scott Chacon. <a href="http://git-scm.com/book">Pro Git</a> // 2009.</li>
<li><a href="http://gruntjs.com/getting-started">Grunt: Getting started</a> // 2013.</li>
<li>Документация по <a href="https://npmjs.org/doc/cli/npm.html">NPM</a> и <a href="https://npmjs.org/doc/files/package.json.html"><code>package.json</code></a>.</li>
<li>Документация по шаблонизатору <a href="https://github.com/mailru/fest">Fest</a>.</li>
<li>Антон Шевчук. <a href="http://anton.shevchuk.name/jquery-book/">jQuery для начинающих</a> // 2013.</li>
</ol>
<h3 id="-">Лекция</h3>
<p>Меня зовут Антон Епрев, в компании Mail.ru я руковожу группой фронтенд разработчиков проекта «Почта». Вести курс мне будут помогать мои коллеги: Егор Дыдыкин и Иван Чашкин. Егор руководит разработкой главной страницы Mail.ru и портальной навигацией, умеет делать такие веб-страницы, которые браузер быстро загружает и отрисовывает. Иван занимается разработкой веб-версии почты для смартфонов, знает если не абсолютно все, то безусловно очень много про особенности мобильных браузеров.</p>
<p>Курс фронтенд разработки состоит из трех модулей, восьми совмещенных занятий (на которых лекционная часть и практическая будут идти вместе), трех контрольных рубежей и презентации проекта. В общей сложности курс состоит из двенадцати занятий.</p>
<p>Обращаю ваше внимание, что на совмещенных занятиях будет вестись видеосъемка.</p>
<p>Сегодняшнее совмещенное занятие будет посвящено знакомству с курсом, инструментам и настройке рабочего окружения.</p>
<p>Дадим определение основных понятий.</p>
<p>Веб-приложение — клиент-серверное приложение, в котором клиентом выступает браузер, а сервером — веб-сервер. Логика веб-приложения распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, обмен информацией происходит по сети. Одним из преимуществ такого подхода является тот факт, что клиенты не зависят от конкретной операционной системы пользователя, поэтому веб-приложения являются межплатформенными сервисами [<a href="http://ru.wikipedia.org/wiki/Веб-приложение">Википедия</a>].</p>
<p>Этот курс посвещен разработке той части веб-приложения, которая работает на стороне клиента – в браузере. От сюда и название – клиент-сайд. Другое название – front-end, тогда как часть веб-приложения, работающая на стороне сервера, называется back-end.</p>
<p>В результате изучения курса вы освоите современную разработку клиент-сайда веб-приложений; узнаете тонкости технологий HTTP, HTML 5, CSS 3, JavaScript, DOM, Events, Host Objects, AJAX; получите необходимую базу знаний о работе браузера (десктоп, смартфоны, планшеты), клиент-серверной архитектуре, архитектуре веб-приложений (события, модули, организации кода) и приобретёте  навыки работы с DOM, асинхронного и событийно-ориентированного программирования, сетевого взаимодествия (AJAX, WebSockets), организации многопоточности в браузере, использования CSS препроцессоров, отладки веб-приложений и сборки проекта с помощью Grunt для раскладки на сервер.</p>
<p>Для успешной сдачи курса необходимо самостоятельно реализовать клиен-сайд для однопользовательской игры с использованием смартфона в качестве игрового контроллера.</p>
<p>На протяжении всего семестра у вас будет три контрольных рубежа. Каждый рубежный контроль вместе с выполнением части проектной работы сопроваждается устным контроллем знаний. Прохождение первого контрольного рубежа дает возможность пройти второй рубеж, второго – третий. Программа предполагает своевременную сдачу каждого контрольного рубежа. Итоговый рейтинг по дисциплине представляет собой сумму баллов, полученных за прохождение рубежных контролей и домашних заданий. Для успешной аттестации по данному курсу студентам необходимо набрать пороговый рейтинг — 60 баллов. При пересчете баллов студенты могут получить итоговую оценку: 0–59 неудовлетворительно, 60–74 удовлетворительно, 75–89 хорошо, 90–100 отлично.</p>
<p>Каковы критерии оценки при прохождении рубежного контроля?</p>
<ol>
<li>Соответствие результата предъявляемым требованиям.</li>
<li>Оптимальность предлагаемого решения.</li>
<li>Практичность решения (возможность дальнейшего применения в работе).</li>
<li>Качество оформления результатов работы.</li>
<li>Доказательность аргументации при защите работы.</li>
</ol>
<p>Проектная работа ведется в группах по 2–3 человека (роли каждого должны быть представлены при формировании группы).</p>
<p>Вводная часть занятия окончена. Переходим в основной части.</p>
<p>Долгое время JavaScript был прерогативой клиент-сайда. Но с выходом <a href="http://nodejs.org">Node.js</a> появилась возможность использовать JavaScript для написания высокопроизводительных приложений, исполняющихся на стороне сервера. С помощью языка программирования, которым владеет каждый фронтед разработчик, теперь стало возможным создавать различные инструметы, такие как системы сборки проекта, его тестирования и развертывания. Сегодня JavaScript является <a href="http://adambard.com/blog/top-github-languages-for-2013-so-far/">самым популярным языком программирования</a> среди создаваемых на GitHub проектов.</p>
<p>Вместе с дистрибутивом Node.js распространяется и <a href="https://npmjs.org">NPM</a> (Node Packaged Modules) — это менеджер пакетов для Node.js. У Java есть Maven, CPAN у Perl, а у Python есть pip, так и у разработчиков на Node.js есть NPM.</p>
<p>В качестве системы контроля верский кода мы будем использовать Git. Эту и следующие презентации вы сможете найти на <a href="https://github.com/eprev/frontend">GitHub</a>.</p>
<p>У каждого из вас уже имеется опыт разработки клиент-сайда, возможно, у кого-то этот опыт не ограничивается проектом, выполненным в прошлом семестре в рамках курса веб-технологий. И скорее всего, проект этот несложный. Такие проекты, обычно, состоят из одного-двух JavaScript файлов и CSS файла со стилями, которые браузер загружает по отдельности вместе с HTML кодом страницы. Такой подход перестает работать, когда проект начинает насчитывать тысячи строк кода JavaScript и стилей CSS. Работать с такими большими файлами неудобно, поэтому, как и в ситуации с программами, написанными на других языках программирования, прибегают к разбиению кода на модули, каждый из которых хранится в отдельном файле. Теперь для функционирования веб-приложения в браузере было бы необходимо загрузить десятки, а то и сотни, файлов JavaScript и CSS. Как вы должно быть уже знаете — это крайне неэффективно. Поэтому перед развертыванием проекта на сервере необходимо произвести его сборку: объединить множество JavaScript файлов в одну или несколько сборок, так же поступить и с CSS файлами, после чего эти сборки минифицировать. Минификация — это процесс сжатия исходного когда с сохранением его функциональности. Как правило, уменьшение размеры файлов достигается за счет удаления ненужных символов (таких как пробелы, переводы строк и комментарии) и замены имен переменных и функций на короткие варианты. На сегодняшний день самым популярным инструментом для сборки проектов является <a href="http://gruntjs.com/">Grunt</a>. Его без труда может установить каждый, воспользовавшись NPM.</p>
<p>Мы продолжаем двигаться от простых веб-приложений к сложным. Следующим этапом в веб-разработке становится Single Page Application — это веб-приложение, которое живет в браузере продолжительное время без березагрузки страницы. В таком приложении все дополнительные ресурсы загружаются по мере необходимости, а для отрисовки интерфейса используется клиентская шаблонизация. Существует огромное множество JavaScript шаблонизаторов, мы в компании разработали свой. <a href="https://github.com/mailru/fest">Fest</a> обеспечивает высокую производительность и возможность использования шаблонов на стороне сервера. Например, главная страница Mail.ru формируется на стороне сервера с помощью скомпилированного в JavaScript код фестового шаблона.</p>
<h3 id="-">Практика</h3>
<p>Создайте директорию для проекта.</p>
<pre><code class="lang-bash">$ mkdir ИМЯ-ПРОЕКТА</code></pre>
<p>Создайте <a href="https://npmjs.org/doc/files/package.json.html"><code>package.json</code></a>.</p>
<pre><code class="lang-bash">$ npm init</code></pre>
<p>Установите Grunt и <code>grunt-contrib-connect</code>.</p>
<pre><code class="lang-bash">$ npm install grunt-cli -g
$ npm install grunt grunt-contrib-connect --save-dev</code></pre>
<p>Создайте <code>Gruntfile.js</code> и настройте таск <code>connect</code>.</p>
<pre><code class="lang-javascript">module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(grunt)</span> {</span>

    grunt.initConfig({
        connect: {
            server: {
                options: {
                    keepalive: <span class="literal">true</span>, <span class="comment">/* работать постоянно */</span>
                    port: <span class="number">8000</span>, <span class="comment">/* номер порта */</span>
                    base: <span class="string">'public'</span> <span class="comment">/* публичная директория */</span>
                }
            }
        }
    });

    grunt.loadNpmTasks(<span class="string">'grunt-contrib-connect'</span>);

};</code></pre>
<pre><code class="lang-bash">$ grunt connect
Running <span class="string">"connect:server"</span> (connect) task
Waiting forever...
Started connect web server on http://localhost:8000</code></pre>
<p>Создайте <code>public/index.html</code>.</p>
<p>Установите <code>grunt-fest</code> и настройте таск <code>fest</code>.</p>
<pre><code class="lang-bash">$ npm install grunt-fest --save-dev</code></pre>
<pre><code class="lang-javascript">module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(grunt)</span> {</span>

    grunt.initConfig({
        connect: {
            server: {
                options: {
                    keepalive: <span class="literal">true</span>,
                    port: <span class="number">8000</span>,
                    base: <span class="string">'public'</span>
                }
            }
        },
        fest: {
            templates: {
                files: [{
                    expand: <span class="literal">true</span>,
                    cwd: <span class="string">'templates'</span>, <span class="comment">/* исходная директория */</span>
                    src: <span class="string">'*.xml'</span>, <span class="comment">/* имена шаблонов */</span>
                    dest: <span class="string">'public/js/tmpl'</span> <span class="comment">/* результирующая директория */</span>
                }],
                options: {
                    template: <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span> <span class="comment">/* задаем формат функции-шаблона */</span>
                        <span class="keyword">return</span> grunt.template.process(
                            <span class="string">'var &lt;%= name %&gt;Tmpl = &lt;%= contents %&gt; ;'</span>, <span class="comment">/* присваиваем функцию-шаблон переменной */</span>
                            {data: data}
                        );
                    }
                }
            }
        }
    });

    grunt.loadNpmTasks(<span class="string">'grunt-contrib-connect'</span>);
    grunt.loadNpmTasks(<span class="string">'grunt-fest'</span>);

};</code></pre>
<p>Установите <code>grunt-contrib-watch</code> и настройте таск <code>watch</code>.</p>
<pre><code class="lang-javascript">module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(grunt)</span> {</span>

    grunt.initConfig({
        watch: {
            fest: {
                files: [<span class="string">'templates/*.xml'</span>], <span class="comment">/* следим за шаблонами */</span>
                tasks: [<span class="string">'fest'</span>], <span class="comment">/* перекомпилировать */</span>
                options: {
                    atBegin: <span class="literal">true</span> <span class="comment">/* запустить задачу при старте */</span>
                }
            }
        },
        connect: {
            server: {
                options: {
                    port: <span class="number">8000</span>,
                    base: <span class="string">'public'</span>
                }
            }
        },
        fest: {
            templates: {
                files: [{
                    expand: <span class="literal">true</span>,
                    cwd: <span class="string">'templates'</span>,
                    src: <span class="string">'*.xml'</span>,
                    dest: <span class="string">'public/js/tmpl'</span>
                }],
                options: {
                    template: <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
                        <span class="keyword">return</span> grunt.template.process(
                            <span class="string">'var &lt;%= name %&gt;Tmpl = &lt;%= contents %&gt; ;'</span>,
                            {data: data}
                        );
                    }
                }
            }
        }
    });

    grunt.loadNpmTasks(<span class="string">'grunt-contrib-watch'</span>);
    grunt.loadNpmTasks(<span class="string">'grunt-contrib-connect'</span>);
    grunt.loadNpmTasks(<span class="string">'grunt-fest'</span>);

    grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'connect'</span>, <span class="string">'watch'</span>]); <span class="comment">/* задача по умолчанию */</span>

};</code></pre>
<p>Добавьте <a href="https://github.com/gruntjs/grunt-contrib-watch#optionslivereload"><code>livereload</code></a>.</p>
<pre><code class="lang-javascript">module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(grunt)</span> {</span>

    grunt.initConfig({
        watch: {
            fest: {
                files: [<span class="string">'templates/*.xml'</span>],
                tasks: [<span class="string">'fest'</span>],
                options: {
                    atBegin: <span class="literal">true</span>
                }
            },
            server: {
                files: [
                    <span class="string">'public/js/**/*.js'</span>, <span class="comment">/* следим за статикой */</span>
                    <span class="string">'public/css/**/*.css'</span>
                ],
                options: {
                    interrupt: <span class="literal">true</span>,
                    livereload: <span class="literal">true</span> <span class="comment">/* перезагрузить страницу */</span>
                }
            }
        },
        connect: {
            server: {
                options: {
                    livereload: <span class="literal">true</span>, <span class="comment">/* поддержка перезагрузки страницы */</span>
                    port: <span class="number">8000</span>,
                    base: <span class="string">'public'</span>
                }
            }
        },
        fest: {
            templates: {
                files: [{
                    expand: <span class="literal">true</span>,
                    cwd: <span class="string">'templates'</span>,
                    src: <span class="string">'*.xml'</span>,
                    dest: <span class="string">'public/js/tmpl'</span>
                }],
                options: {
                    template: <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
                        <span class="keyword">return</span> grunt.template.process(
                            <span class="string">'var &lt;%= name %&gt;Tmpl = &lt;%= contents %&gt; ;'</span>,
                            {data: data}
                        );
                    }
                }
            }
        }
    });

    grunt.loadNpmTasks(<span class="string">'grunt-contrib-watch'</span>);
    grunt.loadNpmTasks(<span class="string">'grunt-contrib-connect'</span>);
    grunt.loadNpmTasks(<span class="string">'grunt-fest'</span>);

    grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'connect'</span>, <span class="string">'watch'</span>]);

};</code></pre>
<p>Подключите <a href="http://jquery.com">jQuery</a>. Создайте функции для отрисовки каждого из экранов игры.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> $page = $(<span class="string">'#page'</span>);

<span class="comment">/* Конструктор экрана "Лучшие игроки" */</span>
<span class="function"><span class="keyword">function</span> <span class="title">showScoreboardScreen</span><span class="params">()</span> {</span>
    hideMainScreen();
}

<span class="comment">/* Деструктор экрана "Лучшие игроки" */</span>
<span class="function"><span class="keyword">function</span> <span class="title">hideScoreboardScreen</span><span class="params">()</span> {</span>}

<span class="comment">/* Конструктор экрана "Игра" */</span>
<span class="function"><span class="keyword">function</span> <span class="title">showGameScreen</span><span class="params">()</span> {</span>
    hideMainScreen();
}

<span class="comment">/* Деструктор экрана "Игра" */</span>
<span class="function"><span class="keyword">function</span> <span class="title">hideGameScreen</span><span class="params">()</span> {</span>}

<span class="comment">/* Конструктор экрана "Главный" */</span>
<span class="function"><span class="keyword">function</span> <span class="title">showMainScreen</span><span class="params">()</span> {</span>
    $page.html(mainTmpl()); <span class="comment">// Рендерим шаблон</span>
    <span class="comment">// Инициализируем обработчики событий</span>
    $page.find(<span class="string">'.js-scoreboard'</span>).on(<span class="string">'click'</span>, showScoreboardScreen);
    $page.find(<span class="string">'.js-start-game'</span>).on(<span class="string">'click'</span>, showGameScreen);
}

<span class="comment">/* Деструктор экрана "Главный" */</span>
<span class="function"><span class="keyword">function</span> <span class="title">hideMainScreen</span><span class="params">()</span> {</span>
    <span class="comment">// Удаляем установленные обработчики событий</span>
    $page.find(<span class="string">'.js-scoreboard'</span>).off(<span class="string">'click'</span>, showScoreboardScreen);
    $page.find(<span class="string">'.js-start-game'</span>).off(<span class="string">'click'</span>, showGameScreen);
}

showMainScreen();</code></pre>
<p>Заключительный вариант.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> $page = $(<span class="string">'#page'</span>),
    currentScreen = <span class="string">'main'</span>;

<span class="comment">/* Конструктор экрана "Лучшие игроки" */</span>
<span class="function"><span class="keyword">function</span> <span class="title">showScoreboardScreen</span><span class="params">()</span> {</span>
    hideMainScreen(); <span class="comment">// Убиваем экран "Главный"</span>
    currentScreen = <span class="string">'scoreboard'</span>;
    $page.html(scoreboardTmpl()); <span class="comment">// Рендерим шаблон</span>
    <span class="comment">// Инициализируем обработчики событий</span>
    $page.find(<span class="string">'.js-back'</span>).on(<span class="string">'click'</span>, showMainScreen);
}

<span class="comment">/* Деструктор экрана "Лучшие игроки" */</span>
<span class="function"><span class="keyword">function</span> <span class="title">hideScoreboardScreen</span><span class="params">()</span> {</span>
    <span class="comment">// Удаляем установленные обработчики событий</span>
    $page.find(<span class="string">'.js-back'</span>).off(<span class="string">'click'</span>, showMainScreen);
}

<span class="comment">/* Конструктор экрана "Игра" */</span>
<span class="function"><span class="keyword">function</span> <span class="title">showGameScreen</span><span class="params">()</span> {</span>
    hideMainScreen(); <span class="comment">// Убиваем экран "Главный"</span>
    currentScreen = <span class="string">'game'</span>;
    $page.html(gameTmpl()); <span class="comment">// Рендерим шаблон</span>
    <span class="comment">// Инициализируем обработчики событий</span>
    $page.find(<span class="string">'.js-back'</span>).on(<span class="string">'click'</span>, showMainScreen);
}

<span class="comment">/* Деструктор экрана "Игра" */</span>
<span class="function"><span class="keyword">function</span> <span class="title">hideGameScreen</span><span class="params">()</span> {</span>
    <span class="comment">// Удаляем установленные обработчики событий</span>
    $page.find(<span class="string">'.js-back'</span>).off(<span class="string">'click'</span>, showMainScreen);
}

<span class="comment">/* Конструктор экрана "Главный" */</span>
<span class="function"><span class="keyword">function</span> <span class="title">showMainScreen</span><span class="params">()</span> {</span>
     <span class="comment">// Убиваем текущий экран</span>
    <span class="keyword">if</span> (currentScreen === <span class="string">'scoreboard'</span>) {
        hideScoreboardScreen();
    } <span class="keyword">else</span> <span class="keyword">if</span> (currentScreen === <span class="string">'game'</span>) {
        hideGameScreen();
    }
    currentScreen = <span class="string">'main'</span>;
    $page.html(mainTmpl()); <span class="comment">// Рендерим шаблон</span>
    <span class="comment">// Инициализируем обработчики событий</span>
    $page.find(<span class="string">'.js-scoreboard'</span>).on(<span class="string">'click'</span>, showScoreboardScreen);
    $page.find(<span class="string">'.js-start-game'</span>).on(<span class="string">'click'</span>, showGameScreen);
}

<span class="comment">/* Деструктор экрана "Главный" */</span>
<span class="function"><span class="keyword">function</span> <span class="title">hideMainScreen</span><span class="params">()</span> {</span>
    <span class="comment">// Удаляем установленные обработчики событий</span>
    $page.find(<span class="string">'.js-scoreboard'</span>).off(<span class="string">'click'</span>, showScoreboardScreen);
    $page.find(<span class="string">'.js-start-game'</span>).off(<span class="string">'click'</span>, showGameScreen);
}

showMainScreen();</code></pre>
<h3 id="-">Домашнее задание</h3>
<ol>
<li>Сформировать идею игры.</li>
<li>Определиться с группой и ролями в ней.</li>
<li>Самостоятельно изучить документацию Grunt и сопутствующие расширения, Fest и jQuery.</li>
<li>Создать прототип веб-приложения.</li>
</ol>
<h3 id="-">Техническое задание</h3>
<ol>
<li>Прототип состоит из трех экранов:<ol>
<li>Главный экран (Main Screen). Содержит название игры и пункты главного меню:<ul>
<li>Пункт «Лучшие игроки» ведет на экран «Лучшие игроки».</li>
<li>Пункт «Начать игру» ведет на основной экран игры.</li>
</ul>
</li>
<li>Лучшие игроки (Scoreboard Screen). Содержит название игры и кнопку «Назад», ведущую на главный экран.</li>
<li>Основной экран игры (Game Screen). Содержит кнопку «Назад», ведущую на главный экран.</li>
</ol>
</li>
<li>За отрисовку и последующую инициализацию каждого экрана должна отвечать отдельная функция в JavaScript.</li>
<li>При первой загрузке страницы с игрой появляется главный экран. Переход между экранами должен осуществлятся без перезагрузки страницы.</li>
<li>Для шаблонизации на строне клиента должен использоваться Fest (см. <a href="https://npmjs.org/package/grunt-fest"><code>grunt-fest</code></a> и <a href="https://github.com/mailru/fest">Fest</a>).</li>
<li>На странице с игрой допускается загрузка одного JavaScript файла и одного CSS файла. Сборку этих файлов необходимо осуществить с помощью Grunt (см. <a href="http://npmjs.org/package/grunt-contrib-connect"><code>grunt-contrib-concat</code></a>).</li>
<li>С помощиью Grunt возможно запустить веб-сервер с игрой (см. <a href="https://npmjs.org/package/grunt-contrib-connect"><code>grunt-contrib-connect</code></a>). Страницу с игрой необходимо автоматически перезагружать при изменении исходных JavaScript, XML (Fest) или CSS файлов (см. параметр <code>livereload</code> в задачах <code>grunt-contrib-connect</code> и <a href="https://npmjs.org/package/grunt-contrib-watch"><code>grunt-contrib-watch</code></a>).</li>
</ol>
<p><img src="/pics/prototype-scheme.png" alt="Схема прототипа"></p>
<h2 id="1-2-">1.2 Архитектура веб-приложений</h2>
<h3 id="-">Полезные ресурсы</h3>
<ol>
<li>Addy Osmani. <a href="http://addyosmani.com/largescalejavascript/">Patterns For Large-Scale JavaScript Application Architecture</a> // 2011.</li>
<li>Эдди Османи. <a href="http://largescalejs.ru">Паттерны для масштабируемых JavaScript-приложений</a> // 2011.</li>
<li>Addy Osmani. <a href="http://addyosmani.github.io/backbone-fundamentals/">Developing Backbone.js Applications</a> // 2013.</li>
<li>Документация <a href="http://backbonejs.org">Backbone.js</a>.</li>
<li>Неофициальный перевод документации <a href="http://backbonejs.ru">Backbone.js</a>.</li>
<li>Документация <a href="http://requirejs.org/">RequireJS</a>.</li>
<li>Неофициальный перевод документации <a href="http://requirejs.ru">RequireJS</a>.</li>
<li>Документация <a href="http://underscorejs.org/">Underscore</a>.</li>
<li>Неофициальный перевод документации <a href="http://underscorejs.ru/">Underscore</a>.</li>
</ol>
<h3 id="-">Лекция</h3>
<p>Глобальные переменные в JavaScript доступны везде, локальные — только в области видимости, в которой они определены. Глобальные переменные являются свойствамии объекта <code>window</code>. Поэтому, объявляя глобальные переменные, вы рискуете изменить свойства <code>window</code>. Каждый раз при присвоении значения неопределенной локальной переменной, вы создаете или изменяете глобальную. Использование глобальных переменных является плохой практикой. В текущей спецификации JavaScript отсутствуют модули, которые бы разграничивали области видимости переменных, объявленых внутри. Но существуют несколько приемов, позволяющих реализовать модульность.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> foo = <span class="number">1</span>;
(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> foo = <span class="number">2</span>;
    alert(foo); <span class="comment">// 2</span>
})();
alert(foo); <span class="comment">// 1</span></code></pre>
<p>Конструкция в примере выше называется <em>немедленно-вызываемая функция</em> (Immediately-Invoked Function Expression, IIFE). Мы создаем анонимную функцию и незамедлительно вызываем ее, с параметрами или без.</p>
<p>Пока что наша функция ничего не возвращает, и модулем назвать ее сложно. Рассмотрим пример по сложнее.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> module = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> name = <span class="string">'A'</span>; <span class="comment">// приватная переменная</span>
        <span class="keyword">return</span> {
            say: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="comment">// публичный метод</span>
                alert(name); <span class="comment">// 2</span>
            }
        };
    })();</code></pre>
<p>На этот раз немедленно-вызываемая функция возвращает объект, определяющий интерфейс модуля, с которым уже можно работать в других частях веб-приложения. Такой подход предотвращает попадание приватных переменных и функций в глобальный контекст, где они могут конфликтовать с другими интерфейсами.</p>
<p>В отличии от некоторых других языков программирования, JavaScript не поддерживает модификаторы доступа. Область видимости ограничивает доступность объявленных в ней переменных. Таким образом, объявленные внутри модуля переменные и функции доступны только изнутри этого модуля, а свойства объекта, возвращаемого модулем, будут доступны всем.</p>
<p>При разработке сервер-сайда веб-приложения популярен подход <a href="http://ru.wikipedia.org/wiki/Model-View-Controller">MVC</a> (Model-View-Controller). Обработкой запроса к серверу занимается контроллер (Controller). Контроллер обращается за данными к модели (Model), которая общается с базой данных. Полученые от модели данные контроллер отправлят в представление (View) для формирования ответа на поступивший запрос.</p>
<p><img src="/pics/mvc-ss.png" alt="MVC сервер-сайда"></p>
<p>Так вот, при разработке клиент-сайда больших веб-приложения тоже применяется подход MVC, но в действительности он работает по-другому. Во главе теперь стоит модель. При изменении своего состояния модель оповещает об этом всех слушателей. Представление это интерфейс, то что видит пользователь и с чем работает. Представлет следит за изменения модели и реагирует на них. Но когда пользователь взаимодействует с представлением (например, выполнилняет click по кнопке), представление передает управление контроллеру. Последний в свою очередь вносит изменения в модель и все начинается сначала.</p>
<p><img src="/pics/mvc-cs.png" alt="MVC клиент-сайда"></p>
<p>Как устроен клиент-сайд сложного веб-приложения?</p>
<p>Уровень библиотек.
Уровень ядра приложения.
Уровень модулей.</p>
<blockquote>
<p>Модуль — функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом… предназначенный для использования в других программах [<a href="http://ru.wikipedia.org/wiki/Модуль_(программирование\">Википедия</a>)].</p>
</blockquote>
<p>Модуль веб-приложения состоит из HTML, CSS и JavaScript. Модули характеризуются <a href="http://ru.wikipedia.org/wiki/Связанность_(программирование\">связанностью</a>). Слабая связанность позволяет вносить изменения в один модуль не оказывая при этом влияния на остальные.</p>
<p>Давайте посмотрим на одно из популярный веб-приложений — «Почту».</p>
<p><img src="/pics/email.png" alt="Почта"></p>
<p>Веб-приложение состоит из многих модулей, вот некоторые из них.</p>
<p>Портальное меню (<code>portal-menu</code>).
<img src="/pics/email-portal-menu.png" alt="Модуль Портальное меню"></p>
<p>Тулбар (<code>toolbar</code>).
<img src="/pics/email-toolbar.png" alt="Модуль Тулбар">
<img src="/pics/email-toolbar-2.png" alt="Модуль Тулбар"></p>
<p>Навигация (<code>nav</code>).
<img src="/pics/email-nav.png" alt="Модуль Навигация"></p>
<p>Список писем (<code>letters</code>).
<img src="/pics/email-datalist.png" alt="Модуль Список писем"></p>
<p>Чтобы модули обладали слабой связанностью не только на уровне логическом (JavaScript), но и на уровне представления (CSS), мы в разработке придерживаемся методологии <a href="http://ru.bem.info/">БЭМ</a>.</p>
<p>Что такое БЭМ?</p>
<p>БЭМ расшифровывается как «Блок, Элемент, Модификатор». Это методология разработки веб-проектов, способ удобно делить интерфейс на отдельные блоки и элементы.</p>
<p>Модуль – это блок в терминологии БЭМ. Блок состоит из элементов или других блоков. Например блок <code>toolbar</code>, который показан на рисунках выше, состоит из элементов – кнопок <code>toolbar__button</code>.</p>
<p>Кнопка тулбара (<code>toolbar__button</code>).
<img src="/pics/email-toolbar__button.png" alt="Элемент toolbar__button"></p>
<p>Согласно БЭМ, в имени элемента обязательно должно присутствовать имя блока, которому он принадлежит, и для их разрграничения обычно используется два нижних подчеркивания. Сделано это для того, чтобы минимизировать количество контекстных селекторов при описании стилей блоков и элементов. Зачем это необходимо?</p>
<p>В качестве примера рассмотрим простейший пример реализации кнопки в тулбаре.</p>
<pre><code class="lang-html"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"toolbar"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"button"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span></code></pre>
<pre><code class="lang-css"><span class="class">.toolbar</span> <span class="class">.button</span> <span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> white;</span></span>
<span class="rule">}</span></span></code></pre>
<p>А теперь поместим этот тулбар в окошко, в котором тоже есть кнопки, но другие.</p>
<pre><code class="lang-html"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"window"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"toolbar"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"button"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">class</span>=<span class="value">"button"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span></code></pre>
<pre><code class="lang-css"><span class="class">.toolbar</span> <span class="class">.button</span> <span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> white;</span></span>
<span class="rule">}</span></span>
<span class="class">.window</span> <span class="class">.button</span> <span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> black;</span></span>
<span class="rule">}</span></span></code></pre>
<p>Обе кнопки в примере выше будут черного цвета. Цвет кнопки внутри <code>toolbar</code> оказался перебит значением, заданным по умолчанию для кнопок внутри блока <code>window</code>. Мы оказались в ситуации, когда визуальное оформление элемента <code>button</code> блока <code>toolbar</code>, зависит от окружения, в которое помещен блок. БЭМ позволяет свести такие ситуации к нулю. За счет отказа от использования контекстных селекторов, мы достигаем практически нулевой связности между блоками, блоки становятся независимыми от того окружения, в котором они окажутся.</p>
<pre><code class="lang-html"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"window"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"toolbar"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"toolbar__button"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">class</span>=<span class="value">"window__button"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span></code></pre>
<pre><code class="lang-css"><span class="class">.toolbar__button</span> <span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> white;</span></span>
<span class="rule">}</span></span>
<span class="class">.window__button</span> <span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> black;</span></span>
<span class="rule">}</span></span></code></pre>
<p>Теперь элементы <code>toolbar__button</code> и <code>window__button</code> являются абсолютно независимыми. У таког подхода ко всему прочему есть еще один приятный момент — скорость отрисовки страниц. Чем сложнее селектор в каскадной таблице стилей, тем браузеру дольше находить стили для элементов страницы.</p>
<p>Одни и теже блоки и элементы не всегда выгледят одинаково в итерфейсе. Например, они могут отличаться геометрическими размерами или отличаться графическим содержанием (как это бывает с иконками у тех же самых кнопок). Для этих целей в БЭМ предусмотрены модификаторы. Модификатор это класс, который применяется дополнительно к блоку или элементы с целью изменения его представления. В имени модификатора обязательно присутствует имя блока или элемента, который он изменяет, а для разграничения используется один символ нижнего подчеркивания. Например, <code>toolbar_fixed</code> (модификатор <code>fixed</code> блока <code>toolbar</code>) или <code>toolbar__button_size_xl</code> (модификатор <code>size</code> в значении <code>xl</code> элемента <code>button</code> блока <code>toolbar</code>).</p>
<p>Веб-приложение представляем собой результат работы модулей из которых оно состоит.</p>
<p>Когда модули слабо связаны между собой, то удаление одного, не приведет к некорректной работе остальные модули. Поэтому, модули не должны напрямую обращаться к методам других модулей, вместо этого модули отправляют и принимают собщения. Это частный случай событийно-ориентированного программрования, который применяется при разработки пользовательских интерфейсов.</p>
<p>Ядро веб-приложения отвечает за управление модулями (загрузка, инициализация и освобождение ресурсов), предоставляет средства коммуникации между модулями и занимается обработкой ошибок в приложении.</p>
<p>На уровне библиотек находятся инструменты для работы с DOM, AJAX, парсеры и т.п.</p>
<p>При разработке проектной работы мы будем использовать довольно популярный стек технологий:</p>
<ol>
<li>Уровень библиотек: jQuery и <a href="http://underscorejs.org/">Underscore</a>.</li>
<li>Уровень ядра приложения: <a href="http://backbonejs.org/">Backbone</a>.</li>
<li>Уровень моделуй: <a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a> и <a href="http://requirejs.org/">RequireJS</a>.</li>
</ol>
<p>Underscore это библиотека для манипулирования данными в функциональном стиле. Без этой библиотеки не обойтись при использовании Backbone. Существует более быстрая реализация Underscore – <a href="http://lodash.com/">Lo-Dash</a>. При желании, можете использовать ее в своей проектной работе.</p>
<p>Мы уже видели как можно создавать модули в JavaScript с помощью анонимных функций. Теперь когда мы умеем разбивать сложное веб-приложение на модули, то становится актуальной проблема управления зависимостями между модулями. Например, для работы контроллера «Списка писем» необходимы модули с реализацией моделей письма и коллекции писем, а так же модуль работы с представлением списка писем.</p>
<p>Мы рассмотрим, пожалуй, самый популярный механиз определения модулей и их зависимостей в JavaScript. Речь идет о AMD (Asynchronous Module Definition). </p>
<p>Вернемся к примеру с простейшей реализацией модуля в JavaScript.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> A = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> name = <span class="string">'A'</span>; <span class="comment">// приватная переменная</span>
        <span class="keyword">return</span> {
            say: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="comment">// публичный метод</span>
                alert(name);
            }
        };
    })();</code></pre>
<p>В AMD этот модуль следует определить следующим образом:</p>
<pre><code class="lang-javascript">define(<span class="string">'A'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> name = <span class="string">'A'</span>; <span class="comment">// приватная переменная</span>
    <span class="keyword">return</span> {
        say: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="comment">// публичный метод</span>
            alert(name);
        }
    };
});</code></pre>
<p>А следующая запись определяет модуль <code>B</code>, который зависит от модуля <code>A</code>.</p>
<pre><code class="lang-javascript">define(<span class="string">'B'</span>, [<span class="string">'A'</span>], <span class="function"><span class="keyword">function</span> <span class="params">(A)</span> {</span>
    <span class="keyword">var</span> name = <span class="string">'B'</span>; <span class="comment">// приватная переменная</span>
    <span class="keyword">return</span> {
        say: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="comment">// публичный метод</span>
            A.say(); <span class="comment">// обращение к публичному методу модуля A</span>
            alert(name);
        }
    };
});</code></pre>
<p>Интерфейсы зависимых модулей передаются в качестве параметров в функцию-конструктор определяемого модуля. AMD это не библиотека, это спецификация, и функция <code>define</code> не определена в JavaScript. Для загрузки модулей, определенных с помощью механизма AMD, используется RequireJS.</p>
<p>Теперь разберемся с ядром веб-приложения. Оно построено будет с использованием Backbone.</p>
<p>Backbone состоит из моделей (models), коллекций (collections) и представлений (views). Как вы заметили, контроллеры отсутсвуют в Backbone. Представления в Backbone, в отличие от MVC, знают что делать при взаимодействии пользователя с ними.</p>
<p>Данные, с которыми оперирует ваше веб-приложение, в Backbone представлены моделями, которые можно создавать, изменять, валидировать, уничтожать или сохранять на сервере. При каждом изменении данных в моделе, модель бросает событие <code>change</code>, что позволяет среагировать на эти измения, например, перерисовать часть интерфейса. Модель используется для представления сущности, а для представления множества сущностей используются коллекции. Например, на экране «Лучшие игроки» в нашей проектной работе будет выводиться список игроков, отсортированный по количеству заработанных очков. Модель — игрок, коллекция – список игроков. Backbone предоставляет методы для манипулирования коллекциями. В нашем случае потребуется упорядочить коллекцию по значению атрибута «счет» модели.</p>
<p>Базовым объектом в Backbone является <code>Events</code>. Любой другой объект, к которому примиксовать <code>Events</code>, унаследует возможность бросать и подписывать произвольные события. Например:</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> object = {};

_.extend(object, Backbone.Events);

object.on(<span class="string">"alert"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(msg)</span> {</span>
  alert(<span class="string">"Triggered "</span> + msg);
});

object.trigger(<span class="string">"alert"</span>, <span class="string">"an event"</span>);</code></pre>
<p>В этом примере мы создаем объект <code>object</code>, и с помощью метода <code>extend</code> библиотеки <code>Underscore</code> переносим в него методы из объекта <code>Backbone.Events</code>, это и есть миксование. Теперь нам доступны в объекте <code>object</code> методы <code>on</code> и <code>trigger</code>, которые используюся для подписки на событие и инициирования события соотвественно.</p>
<p>Объект <code>Events</code> уже примиксован к остальным объектам Backbone, например, таким как <code>Model</code> или <code>Collection</code>.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> PlayerModel = Backbone.Model.extend({
    });

<span class="keyword">var</span> player = <span class="keyword">new</span> PlayerModel();

player.on(<span class="string">'change:name'</span>, <span class="keyword">function</span>(model, name) {
    alert(<span class="string">'Player name is '</span> + name);
});

player.set({name: <span class="string">'Mark'</span>});</code></pre>
<p>Здесь мы создаем модель <code>PlayerModel</code>, а затем создаем экземпляр <code>player</code> созданной модели. Создаем обработчик события <code>change:name</code> для объекта <code>player</code> и устанавливаем значение атрибута <code>name</code>, используя метод <code>set</code>. Последний приведет к инициализации события <code>change:name</code>, для которого мы создали обработчик.</p>
<p>Обратимся к представлениям – объекты <code>View</code> в Backbone. <code>View</code> не привязаны к какому-либо шаблонизатору, например, будет достаточно того, что есть в библиотеке <code>Underscore</code>, от которой зависит Backbone. Напомню, мы будем использовать шаблонизатор Fest.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> PlayerView = Backbone.View.extend({

    tagName: <span class="string">"li"</span>,
    className: <span class="string">"score__item"</span>,
    template: fest[<span class="string">'player'</span>],

    events: {
        <span class="string">"click .button_delete"</span>: <span class="string">"destroy"</span>
    },

    initialize: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">this</span>.listenTo(<span class="keyword">this</span>.model, <span class="string">"change"</span>, <span class="keyword">this</span>.render);
    },

    render: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">this</span>.$el.html(<span class="keyword">this</span>.template(<span class="keyword">this</span>.model.attributes));
        <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    destroy: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>

    }
});

<span class="keyword">var</span> playerView = <span class="keyword">new</span> PlayerView({
        model: player,
        id: <span class="string">"player-"</span> + player.id
    });</code></pre>
<p>Здесь мы создаем представление <code>PlayerView</code> и переопределяем значения по умолчанию для следующих свойств представлений. Свойство <code>tagName</code> указывает на тип HTML элемента, который будет создан, если при создании экземпляра представления не будет передан уже существующий элемент в свойстве <code>el</code>. Таким образом, у представления всегда есть элемент. Находится он в DOM или нет – неважно. Свойство <code>className</code> определяет значение аттрибута <code>class</code> для создаваемого элемента <code>tagName</code>. В свойство <code>template</code> необходимо передать функцию-шаблонизатор. Свойство <code>events</code> позволяет в удобном виде определить обработчики событий на элементах этого представления. В примере выше метод представления <code>destroy</code> будет назначен обработчиком события <code>click</code> на элементах с классом <code>button_delete</code>. Свойство <code>initialize</code> определяет функцию, которая будет вызвана при создании экземпляра представления. Здесь мы подписываемся на событие <code>change</code> модели, ассоциированной с созданным экземпляром нашего представления, а в качестве обработчика события указываем метод <code>render</code>. То есть при любых изменения в моделе, будем перерисовывать представление. Метод <code>listenTo</code>, унаследованный от объекта <code>Events</code>, позволяет создавать обработчик события и связать его с текущим контекстом. Свойство <code>render</code> определяет функцию, которая будет отвечать за перерисовку представления. В нашем случае в элемент, который связан с экземпляром представления, мы вставляем результат вызова функции-шаблонизатора.</p>
<p>Вашим предыдущим домашним заданием было сделать прототип веб-приложения, в котором переключение между экранами не приводило к перезагрузке страницы. Вы просто изменяли содержимое элемента страницы, при этом адрес у страницы оставался неизменным. Это неудобно по следующим причинам:</p>
<ol>
<li>Чтобы попасть на определенный экран, каждый раз необходимо совершать последовательность действий, приводящих к его появлению.</li>
<li>Переходы между экранами не отображатся в истории навигации веб-браузера. При переходе на новый экран, нет возможности перейти к предыдущему по нажатию на кнопку Back веб-браузера.</li>
</ol>
<p>Для решения этих проблем используется механизм с подменой якоря страницы. Якорь — это часть URL страницы. Начинается с символа <code>#</code> и всегда находится в конце URL. Если каждому экрану в нашем веб-приложении назначить уникальный якорь и начать отслеживать изменение этого якоря в адресе страницы, то пропадает необходимость в обработчиках события <code>click</code> для ссылок, которые осуществляют переход между экранами. Достаточно указать нужное значение якоря в артрибуте <code>href</code> и воспользоваться функционалом, который предоставляет Backbone.</p>
<p>Для того, что бы Backbone начал отслеживать изменения якоря в адресе страницы, необходимо вызвать <code>Backbone.history.start()</code> когда документ будет уже загружен. Как это работает? Все очень просто, веб-браузер при изменении якоря бросает событие  <code>hashchange</code> от имени <code>window</code>, а Backbone начинает его слушать.</p>
<p>Важной частью современного веб-приложения является роутинг. Это механизм, который позволяет устанавливать связь между адресом страницы и действиями, которые необходимо выполнять каждый раз при измении адреса страницы на указанное значение. В Backbone за роутинг отвечает объект <code>Router</code>.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> Router = Backbone.Router.extend({
    routes: {
        <span class="string">'scoreboard'</span>: <span class="string">'scoreboardAction'</span>,
        <span class="string">'game'</span>: <span class="string">'gameAction'</span>,
        <span class="string">'*default'</span>: <span class="string">'defaultActions'</span>
    },
    defaultActions: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>},
    scoreboardAction: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>},
    gameAction: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>}
});

<span class="keyword">new</span> Router();</code></pre>
<p>В этом примере мы указываем, что при изменении якоря на значение <code>#scoreboard</code> следует выполнить метод экземпляра объекта <code>scoreboardAction</code>, при значении якоря равным <code>#game</code> – выполнить метод <code>gameAction</code>, а для всех остальных значений якоря – метод <code>defaulActions</code>. И неважно каким образом был изменен якорь страницы (программно или пользователь ввел его в адресной строке), роутер выполнит указанные обработчики.</p>
<p>Подробное изучение возможностей Backbone не является целью нашего занятия, это будет вашим домашним заданием. Поэтому мы двигаемся дальше.</p>
<p>Наше веб-приложение необходимо разбить на мелкие модули и определить зависимости между ними. Мы будем использовать механизм AMD и придерживаться соглашения «один модуль — один файл».</p>
<p>Напомню, что шаблоны Fest мы компилируем в JavaScript файлы с помощью Grunt. Поэтому необходимо изменить процедуру формирования этих файлов. Для этого в <code>Gruntfile.js</code> необходимо заменить значение параметра <code>template</code> задачи <code>fest</code> на следующее:</p>
<pre><code class="lang-javascript">template: <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
    <span class="keyword">return</span> grunt.template.process(
        <span class="comment">// 'var &lt;%= name %&gt;Tmpl = &lt;%= contents %&gt; ;',</span>
        <span class="string">'define(function () { return &lt;%= contents %&gt; ; });'</span>,
        {data: data}
    );
}</code></pre>
<p>Для загрузки модулей, определенных с помощью механизма AMD, используется RequireJS. С помощью RequireJS достаточно указать на странице всего один JavaScript файл, и все зависимые модули будут автоматически им загружены. Это очень сильно упращает разработку. Сравните, как у нас подключались JavaScript файлы до этого:</p>
<pre><code class="lang-html"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/js/lib/jquery.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/js/tmpl/main.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/js/tmpl/scoreboard.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/js/tmpl/game.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre>
<p>И как станут подключаться теперь:</p>
<pre><code class="lang-html"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">data-main</span>=<span class="value">"js/main"</span> <span class="attribute">src</span>=<span class="value">"js/lib/require.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre>
<p>Здесь мы подключаем на страницу только саму библиотеку RequireJS и указываем в атрибуте <code>data-main</code> имя файла, который следуем загрузить после того как библиотека проинициализируется. Файл <code>js/main.js</code> содержит настройки для RequireJS и определяет загрузочный модуль. В нашем случае загрузочный модуль содержит всего одну инструкцию (инициализирование <code>Backbone.history</code>) и зависит от модуля с роутером:</p>
<pre><code class="lang-javascript">define([
    <span class="string">'router'</span>
], <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    Backbone.history.start();
});</code></pre>
<p>Благодаря AMD и RequireJS вам больше не нужно следить, чтобы все необходимые файлы были подключены к странице в определенном порядке. Они сделают это все за вас.</p>
<p>Дело за малым — настроить роутинг, реализовать представления, коллекции и модели. Это будет вашим домашним заданием. Мы подготовили структуру проекта, определили все модули-пустышки, необходимые для запуска веб-приложения. Для этого вам потребуется к репозиторию вашего проекта добавить репозиторий <a href="https://github.com/eprev/frontend-stub/">github.com/eprev/frontend-stub/</a> и влить содержимое ветки v2:</p>
<pre><code class="lang-bash">$ git remote add tp https://github.com/eprev/frontend-stub.git
$ git fetch tp
$ git merge tp/v1</code></pre>
<h3 id="-">Домашнее задание</h3>
<ol>
<li>Самостоятельно изучить документацию Underscore, Backbone и RequireJS.</li>
<li>Подключить к репозиторию проектной работы <a href="https://github.com/eprev/frontend-stub">github.com/eprev/frontend-stub</a> и объединить содержимое своего проекта с содержимым ветки <a href="https://github.com/eprev/frontend-stub/tree/v2">v2</a>.</li>
<li>Доработать прототип в соотвествии техническому заданию.</li>
</ol>
<h3 id="-">Техническое задание</h3>
<ol>
<li><p>Модель игрока должна состояить из следующих атрибутов:</p>
<ul>
<li><code>name</code> – имя игрока (значение по умолчанию: <code>&#39;&#39;</code>)</li>
<li><code>score</code> – количество очков (значение по умолчанию: <code>0</code>)</li>
</ul>
</li>
<li><p>Список игроков должено состоять из 10 разных записей и программно упорядочен по убыванию атрибута <code>score</code>.</p>
</li>
<li><p>Переходы между экранами веб-приложения должны отражаться в истории веб-браузера, таким образом, чтобы корректно работали кнопки Back и Forward. Для этой цели к адресу веб-страницы добавляется якорь (<code>#</code>):</p>
<ul>
<li><code>#scoreboard</code> для экрана «Лучшие игроки»;</li>
<li><code>#game</code> для основного экрана игры;</li>
<li><code>#</code> для экрана «Главное меню».</li>
</ul>
</li>
</ol>
<h1 id="2-dom-ajax">2 DOM &amp; AJAX</h1>
<h2 id="2-1-dom-events">2.1 Работа с DOM, Events</h2>
<ul>
<li><a href="https://developer.mozilla.org/en/docs/DOM">DOM</a>.</li>
<li><a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html">Events</a>.</li>
<li><a href="http://ru.wikipedia.org/wiki/Событийно-ориентированное_программирование">Событийно-ориентированное_программирование</a>.</li>
<li><a href="http://es5.github.io/#x4.3.8">Host Objects</a>.</li>
</ul>
<p>ДЗ:</p>
<ol>
<li>Реализация игровой механики (на протяжении последующих домашних заданий в этом модуле).</li>
<li>Сделать форму ввода имени игрока после окончания игры.</li>
<li>Релазиовать PubSub:<ol>
<li>RulleyView подписывается на showScreen и скрывает остальные экраны.</li>
<li>Бросить gaveOver, на который показывать ввод имени игрока. А после ввода, должна показывать скрин списка игроков.</li>
</ol>
</li>
</ol>
<h2 id="2-2-">2.2 Сетевое взаимодествие</h2>
<ul>
<li>HTTP.</li>
<li>AJAX.</li>
<li>CORS.</li>
<li>WebSockets.</li>
</ul>
<h3 id="-restful-api-score">Серверное RESTful API для работы со Score</h3>
<ol>
<li>GET /scores<ol>
<li>Код 200 - возвращает всю коллкцию scores или первые x элементов (заданные через ?limit=x) отсортированную по убыванию счета игрока</li>
</ol>
</li>
<li>GET /scores/:id<ol>
<li>Код 200 - возвращает модель с переданным id</li>
<li>Код 400 - не верные входные данные</li>
<li>Код 404 - модель с указанным id не найдена</li>
</ol>
</li>
<li>POST /scores<ol>
<li>Request Body: {&quot;name&quot;: &quot;<name>&quot;, &quot;score&quot;: <score>}</li>
<li>Код 200 - возвращает id созданной модели</li>
<li>Код 400 - не верные входные данные</li>
</ol>
</li>
<li>DEL /scores/:id<ol>
<li>Код 200 - удаляет модель с переданным id</li>
<li>Код 400 - не верные входные данные</li>
<li>Код 404 - модель с указанным id не найдена</li>
</ol>
</li>
<li>PUT /scores/:id<ol>
<li>Request Body: {&quot;id&quot;: <id>, &quot;name&quot;: &quot;<name>&quot;, &quot;score&quot;: <score>}</li>
<li>Код 200 - обновляет и возвращает модель с переданным id</li>
<li>Код 400 - не верные входные данные</li>
<li>Код 404 - модель с указанным id не найдена</li>
</ol>
</li>
</ol>
<h3 id="-">Техническое задание</h3>
<ol>
<li>Создать новый view GameOver на экране Game<ol>
<li>View должна содержать поле ввода имени игрока, кнопку сохранения и отображать переданный при инициализации счет игрока.</li>
<li>При сабмите формы создается модель score с указанными в форме данными и добавляется в коллекцию scores</li>
<li>Модель сохраняется на сервер.</li>
<li>На время сохранения форма блокируется</li>
<li>При ошибке сохранения пользователю выводится ошибка и форма разблокируется</li>
<li>После успешного сохранения форма разблокируется, сбрасывается и происходит переход на экран Scoreboard</li>
</ol>
</li>
<li>Модифицировать экран Scoreboard для получения данных с сервера (топ 10)<ol>
<li>При отображении экрана происходит fetch коллекции scores</li>
<li>Во время загрузки пользователю отображается сообщение о загрузке</li>
<li>В случае ошибки загрузки пользователю отображается соответствующее сообщение с возможностью обновить экран</li>
<li>В случае успешной загрузки отображается список</li>
</ol>
</li>
</ol>
<p>Литература:</p>
<ol>
<li>Tiffany Brown. <a href="http://dev.opera.com/articles/view/xhr2/">Introduction to XMLHttpRequest Level 2</a> // 2012.</li>
<li>Armin Ronacher. <a href="http://lucumr.pocoo.org/2012/9/24/websockets-101/">Websockets 101</a> // 2012.</li>
<li><a href="http://www.restapitutorial.com/httpstatuscodes.html">HTTP Status Codes</a>.</li>
</ol>
<p>ДЗ:</p>
<ol>
<li>Наладить взаимодествие с сервером с помощью AJAX.</li>
</ol>
<h2 id="2-3-">2.3 Хранение данных на клиенте</h2>
<ul>
<li>Cookies.</li>
<li><a href="http://www.html5rocks.com/en/features/storage">Storage</a>.</li>
</ul>
<p>ДЗ:</p>
<ol>
<li>Организовать хранение пользовательских настроек на клиенте.</li>
<li>Сохранять результаты игры на клиенте, при остуствии связи с сервером.</li>
</ol>
<h1 id="3-">3 Отладка и мобильный веб</h1>
<h2 id="3-1-web-inspector-css">3.1 Web Inspector и препроцессоры CSS</h2>
<ul>
<li><a href="http://sass-lang.com">Sass</a>.</li>
<li><a href="https://developers.google.com/chrome-developer-tools/docs/css-preprocessors">Source Maps</a>.</li>
</ul>
<p>ДЗ:</p>
<ol>
<li>Перевести CSS на Sass.</li>
</ol>
<h2 id="3-2-">3.2 Производительность</h2>
<h3 id="-">Полезные ресурсы</h3>
<ol>
<li>Yahoo Developer Network. <a href="http://developer.yahoo.com/performance/rules.html">Best Practices for Speeding Up Your Web Site</a>.</li>
</ol>
<h3 id="-">Лекция</h3>
<ul>
<li>HTTP Cache.</li>
<li>HTTP Waterfall.</li>
<li>Reflow/Repaint.</li>
<li>Web workers.</li>
<li><a href="http://www.html5rocks.com/en/tutorials/appcache/beginner/">App Cache</a>.</li>
<li>Prefetching.</li>
<li>CSS специфичность.</li>
</ul>
<h3 id="-">Домашнее задание</h3>
<ol>
<li>Организовать сборку ресурсов для production и development окружения.</li>
</ol>
<h3 id="-">Техническое задание</h3>
<ol>
<li>Структура файлов (production):<pre><code>production/
 js/
     libs<span class="variable">.js</span>
     main<span class="variable">.js</span>
 css/
     main<span class="variable">.css</span></code></pre>
</li>
<li>CSS проекта собирается с флагом  <code>style: &#39;compressed&#39;</code> в файл <code>production/css/main.css</code></li>
<li>Сборка main.js осуществляется с помощью <a href="https://npmjs.org/package/grunt-contrib-requirejs"><code>grunt-contrib-requirejs</code></a>).</li>
<li>Минификация файла осуществялется с помощью <a href="https://npmjs.org/package/grunt-contrib-uglify"><code>grunt-contrib-uglify</code></a>.</li>
<li>В продакшене для реализации AMD используется <a href="https://github.com/jrburke/almond"><code>almond</code></a>.</li>
<li>Запуск production <code>$ NODE_ENV=production node app.js</code></li>
<li>Определение в <code>node.js</code> текущей версии <code>process.env.NODE_ENV == &#39;production&#39;</code><pre><code class="lang-JavaScript"><span class="function"><span class="title">if</span><span class="params">( process.env.<span class="variable">NODE_ENV</span> == 'production' )</span>{
 <span class="title">app</span>.<span class="title">use</span><span class="params">(express.<span class="function_name">static</span>(path.<span class="function_name">join</span>(<span class="variable">_</span>_dirname, 'production')))</span>;
}<span class="title">else</span>{
 <span class="title">app</span>.<span class="title">use</span><span class="params">(express.<span class="function_name">static</span>(path.<span class="function_name">join</span>(<span class="variable">_</span>_dirname, 'public')))</span>;
}</code></pre>
</li>
</ol>
<p>ДЗ:</p>
<ol>
<li>Сделать прогресс-бар загрузки ресурсов.</li>
<li>Настроить HTTP заголовки, отвечающие за кеширование ресурсов.</li>
</ol>
<h2 id="3-3-">3.3 Возможности смартфонов</h2>
<ul>
<li>Акселерометр.</li>
<li>Гироскоп.</li>
<li>Тач-события.</li>
</ul>
<h3 id="rpc-api">RPC API</h3>
<p>Создаем экземпляр Connector с указанием remote: &#39;/&lt;тип клиента: console|player&gt;&#39;.</p>
<pre><code class="lang-JavaScript">var <span class="built_in">server</span> = <span class="keyword">new</span> Connector({
    remote: <span class="comment">'/console'</span>
});</code></pre>
<p>Через socket.io устанавливается соединение с сервером по пути, указанному в remote, и происходит запрос на получение набора функций, поддерживаемых сервером. Запрос асинхронный, потому Connector предоставляет метод onReady, позволяющий начать работу с сервером, когда все будет готово.</p>
<pre><code class="lang-JavaScript">server<span class="preprocessor">.onReady</span>(function(){
    server<span class="preprocessor">.someServerSideFunction</span>()<span class="comment">;</span>
})<span class="comment">;</span></code></pre>
<p>При желании можно часть или все функции объявить при инициализации и вызывать их сразу. Запросы на вызов серверной функции складываются в очередь и будут запущены после полчения списка серверных функций.</p>
<pre><code class="lang-JavaScript">var <span class="built_in">server</span> = <span class="keyword">new</span> Connector({
    <span class="built_in">server</span>: [<span class="comment">'getToken', 'bind'],</span>
    remote: <span class="comment">'/console'</span>
});

<span class="built_in">server</span>.getToken(<span class="keyword">function</span>(token){});</code></pre>
<p>На сервере реализованы следующие функции:</p>
<pre><code class="lang-JavaScript"><span class="title">server</span>.getToken(function(token){
    token // токен для иниализации связи
});

// для первичной инициализации связки по токену
<span class="title">server</span>.bind({token:<span class="string"> '&lt;token&gt;'</span>}, function(<span class="typedef"><span class="keyword">data</span>)<span class="container">{
    <span class="title">data</span>.<span class="title">status</span> // '<span class="title">success'</span> в случае успеха, '<span class="title">undefined</span> <span class="title">token'</span> в случае ошибки, '<span class="title">busy</span> <span class="title">token'</span> в случае, если токен занят
    <span class="title">data</span>.<span class="title">guid</span> // <span class="title">guid</span> связки в случае успеха
}</span>);</span>

// для восстановления связки, когда guid уже получен
<span class="title">server</span>.bind({guid:<span class="string"> '&lt;guid&gt;'</span>}, function(<span class="typedef"><span class="keyword">data</span>)<span class="container">{
    <span class="title">data</span>.<span class="title">status</span> // '<span class="title">success'</span> в случае успеха, '<span class="title">undefined</span> <span class="title">guid'</span> в случае ошибки
}</span>);</span></code></pre>
<p>Так же Connector поддерживает следующие события</p>
<pre><code class="lang-JavaScript">server.<span class="literal">on</span>(<span class="string">'connect'</span>, <span class="reserved">function</span>(){}); <span class="regexp">//</span> установка соединения
server.<span class="literal">on</span>(<span class="string">'disconnect'</span>, <span class="reserved">function</span>(){}); <span class="regexp">//</span> потеря соединения
server.<span class="literal">on</span>(<span class="string">'reconnect'</span>, <span class="reserved">function</span>(){}); <span class="regexp">//</span> восстановление соединения</code></pre>
<p>Специальное событие для консоли, происходящее когда игрок подключил джойстик</p>
<pre><code class="lang-JavaScript"><span class="title">server</span>.on('player-joined', function(<span class="typedef"><span class="keyword">data</span>)<span class="container">{
    <span class="title">data</span>.<span class="title">guid</span> // <span class="title">guid</span> инициализированной связки
}</span>);</span></code></pre>
<p>Для общения между консолью и джойстиком используется метод send для отправки сообщения от одного клиента и событие message на другом для получения сообщения.</p>
<pre><code class="lang-JavaScript"><span class="title">server</span>.send(<span class="typedef"><span class="keyword">data</span>, function<span class="container">(<span class="title">answer</span>)</span><span class="container">{
    <span class="title">answer</span> // ответ другой стороны
}</span>);</span>

<span class="title">server</span>.on('message', function(<span class="typedef"><span class="keyword">data</span>, answer)<span class="container">{
    <span class="title">data</span> // данные сообщения
    <span class="title">answer</span>('&lt;<span class="title">answer</span>&gt;') // отправка ответа обратно
}</span>);</span></code></pre>
<p>Литература:</p>
<ol>
<li>Chris Wilson, Paul Kinlan. <a href="http://www.html5rocks.com/en/mobile/touchandmouse/">Touch And Mouse. Together Again For The First Time</a> // 2013.</li>
</ol>
<p>ДЗ:</p>
<ol>
<li>Сделать джойстик для смартфонов и организовать взаимодействие на websockets между экранами приложения.</li>
</ol>
<h1 id="-">Полезные ссылки</h1>
<ol>
<li><a href="http://buildnewgames.com">Build New Games. Open Web techniques for cutting-edge game development</a>.</li>
</ol>

        </section>
    </body>
</html>
