---
layout: default
title: Архитектура
---

{::options auto_ids="false" /}

[ГЛАВНАЯ](/)

# 1 Архитектура
{: id="1"}

Содержание:

1.1 [Знакомство, инструменты, настройка окружения](#1.1)

1.1.1 [Полезные ресурсы](#1.1.1)\\
1.1.2 [Смешанное занятие](#1.1.2)\\
1.1.3 [Домашнее задание](#1.1.3)\\
1.1.4 [Техническое задание](#1.1.4)
{:.toc}

1.2 [Архитектура веб-приложений](#1.2)

1.2.1 [Полезные ресурсы](#1.2.1)\\
1.2.2 [Смешанное занятие](#1.2.2)\\
1.2.3 [Домашнее задание](#1.2.3)\\
1.2.4 [Техническое задание](#1.2.4)
{:.toc}

## 1.1 Знакомство, инструменты, настройка окружения
{: id="1.1"}

### 1.1.1 Полезные ресурсы
{: id="1.1.1"}

1. Scott Chacon. [Pro Git](http://git-scm.com/book) // 2009.
2. [Grunt: Getting started](http://gruntjs.com/getting-started) // 2013.
3. Документация по [NPM](https://npmjs.org/doc/cli/npm.html) и [`package.json`](https://npmjs.org/doc/files/package.json.html).
4. Документация по шаблонизатору [Fest](https://github.com/mailru/fest).
5. Антон Шевчук. [jQuery для начинающих](http://anton.shevchuk.name/jquery-book/) // 2013.

### 1.1.2 Смешанное занятие
{: id="1.1.2"}

Меня зовут Иван Чашкин, в компании Mail.ru я занимаюсь разработкой веб-версии мобильной почты для смартфонов. Вести курс мне будут помогать мои коллеги: Егор Дыдыкин и Артем Мезин. Егор руководит разработкой главной страницы Mail.ru и портальной навигацией, умеет делать такие веб-страницы, которые браузер быстро загружает и отрисовывает. Артем занимается разработкой основной версией почты.

Курс фронтенд разработки состоит из трех модулей, шести совмещенных занятий (на которых лекционная часть и практическая будут идти вместе), пяти лекций и четырех контрольных рубежей и защиты проекта. В общей сложности курс состоит из шестнадцати занятий.

Обращаю ваше внимание, что на совмещенных занятиях будет вестись видеосъемка.

Сегодняшнее совмещенное занятие будет посвящено знакомству с курсом, инструментам и настройке рабочего окружения.

Дадим определение основных понятий.

> Веб-приложение — клиент-серверное приложение, в котором клиентом выступает браузер, а сервером — веб-сервер. Логика веб-приложения распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, обмен информацией происходит по сети. Одним из преимуществ такого подхода является тот факт, что клиенты не зависят от конкретной операционной системы пользователя, поэтому веб-приложения являются межплатформенными сервисами [[Википедия](http://ru.wikipedia.org/wiki/Веб-приложение)].

Этот курс посвещен разработке той части веб-приложения, которая работает на стороне клиента – в браузере. От сюда и название – клиент-сайд. Другое название – frontend, тогда как часть веб-приложения, работающая на стороне сервера, называется backend.

В результате изучения курса вы освоите современную разработку клиент-сайда веб-приложений; узнаете тонкости технологий HTTP, HTML 5, CSS 3, JavaScript, AJAX; получите необходимую базу знаний о работе браузера (десктопного и мобильныого), клиент-серверной архитектуре, архитектуре веб-приложений и приобретёте  навыки работы с DOM и Host Objetcs, асинхронного и событийно-ориентированного программирования, сетевого взаимодествия (AJAX, WebSockets), организации многопоточности в браузере, использования CSS препроцессоров, отладки веб-приложений и сборки проекта с помощью Grunt для раскладки на сервер.

Для успешной сдачи курса необходимо самостоятельно реализовать клиен-сайд для однопользовательской игры с использованием смартфона в качестве игрового контроллера.

На протяжении всего семестра у вас будет три контрольных рубежа. Каждый рубежный контроль вместе с выполнением части проектной работы сопроваждается устным контроллем знаний. Прохождение первого контрольного рубежа дает возможность пройти второй рубеж, второго – третий. Программа предполагает своевременную сдачу каждого контрольного рубежа. Итоговый рейтинг по дисциплине представляет собой сумму баллов, полученных за прохождение рубежных контролей и домашних заданий. Для успешной аттестации по данному курсу студентам необходимо набрать пороговый рейтинг — 60 баллов. При пересчете баллов студенты могут получить итоговую оценку: 0–59 неудовлетворительно, 60–74 удовлетворительно, 75–89 хорошо, 90–100 отлично.

Каковы критерии оценки при прохождении рубежного контроля?

1. Соответствие результата предъявляемым требованиям.
2. Оптимальность предлагаемого решения.
3. Практичность решения (возможность дальнейшего применения в работе).
4. Качество оформления результатов работы.
5. Доказательность аргументации при защите работы.

Проектная работа ведется в группах по 2–3 человека (роли каждого должны быть представлены при формировании группы).

Вводная часть занятия окончена. Переходим в основной части.

Долгое время JavaScript был прерогативой клиент-сайда. Но с выходом [Node.js](http://nodejs.org) появилась возможность использовать JavaScript для написания высокопроизводительных приложений, исполняющихся на стороне сервера. С помощью языка программирования, которым владеет каждый фронтед разработчик, теперь стало возможным создавать различные инструметы, такие как системы сборки проекта, его тестирования и развертывания. Сегодня JavaScript является [самым популярным языком программирования](http://adambard.com/blog/top-github-languages-for-2013-so-far/) среди создаваемых на GitHub проектов.

Вместе с дистрибутивом Node.js распространяется и [NPM](https://npmjs.org) (Node Packaged Modules) — это менеджер пакетов для Node.js. У Java есть Maven, CPAN у Perl, а у Python есть pip, так и у разработчиков на Node.js есть NPM.

В качестве системы контроля верский кода мы будем использовать Git. Эту и следующие презентации вы сможете найти на [GitHub](https://github.com/eprev/frontend).

У каждого из вас уже имеется опыт разработки клиент-сайда, возможно, у кого-то этот опыт не ограничивается проектом, выполненным в прошлом семестре в рамках курса веб-технологий. И скорее всего, проект этот несложный. Такие проекты, обычно, состоят из одного-двух JavaScript файлов и CSS файла со стилями, которые браузер загружает по отдельности вместе с HTML кодом страницы. Такой подход перестает работать, когда проект начинает насчитывать тысячи строк кода JavaScript и стилей CSS. Работать с такими большими файлами неудобно, поэтому, как и в ситуации с программами, написанными на других языках программирования, прибегают к разбиению кода на модули, каждый из которых хранится в отдельном файле. Теперь для функционирования веб-приложения в браузере было бы необходимо загрузить десятки, а то и сотни, файлов JavaScript и CSS. Как вы должно быть уже знаете — это крайне неэффективно. Поэтому перед развертыванием проекта на сервере необходимо произвести его сборку: объединить множество JavaScript файлов в одну или несколько сборок, так же поступить и с CSS файлами, после чего эти сборки минифицировать. Минификация — это процесс сжатия исходного когда с сохранением его функциональности. Как правило, уменьшение размеры файлов достигается за счет удаления ненужных символов (таких как пробелы, переводы строк и комментарии) и замены имен переменных и функций на короткие варианты. На сегодняшний день самым популярным инструментом для сборки проектов является [Grunt](http://gruntjs.com/). Его без труда может установить каждый, воспользовавшись NPM.

Мы продолжаем двигаться от простых веб-приложений к сложным. Следующим этапом в веб-разработке становится Single Page Application — это веб-приложение, которое живет в браузере продолжительное время без березагрузки страницы. В таком приложении все дополнительные ресурсы загружаются по мере необходимости, а для отрисовки интерфейса используется клиентская шаблонизация. Существует огромное множество JavaScript шаблонизаторов, мы в компании разработали свой. [Fest](https://github.com/mailru/fest) обеспечивает высокую производительность и возможность использования шаблонов на стороне сервера. Например, главная страница Mail.ru формируется на стороне сервера с помощью скомпилированного в JavaScript код фестового шаблона.

Создайте директорию для проекта.

~~~
$ mkdir epicgame
~~~

Создайте [`package.json`](https://npmjs.org/doc/files/package.json.html).

~~~
$ npm init
~~~

Установите Grunt и `grunt-contrib-connect`.

~~~
$ npm install grunt-cli -g
$ npm install grunt grunt-contrib-connect --save-dev
~~~

Создайте `Gruntfile.js` и настройте таск `connect`.

~~~
module.exports = function (grunt) {

    grunt.initConfig({
        connect: {
            server: {
                options: {
                    keepalive: true, /* работать постоянно */
                    port: 8000, /* номер порта */
                    base: 'public' /* публичная директория */
                }
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-connect');

};
~~~
{:.javascript}

~~~
$ grunt connect
Running "connect:server" (connect) task
Waiting forever...
Started connect web server on http://localhost:8000
~~~

Создайте `public/index.html`.

Установите `grunt-fest` и настройте таск `fest`.

~~~
$ npm install grunt-fest --save-dev
~~~

~~~
module.exports = function (grunt) {

    grunt.initConfig({
        connect: {
            server: {
                options: {
                    keepalive: true,
                    port: 8000,
                    base: 'public'
                }
            }
        },
        fest: {
            templates: {
                files: [{
                    expand: true,
                    cwd: 'templates', /* исходная директория */
                    src: '*.xml', /* имена шаблонов */
                    dest: 'public/js/tmpl' /* результирующая директория */
                }],
                options: {
                    template: function (data) { /* задаем формат функции-шаблона */
                        return grunt.template.process(
                            'var <%= name %>Tmpl = <%= contents %> ;', /* присваиваем функцию-шаблон переменной */
                            {data: data}
                        );
                    }
                }
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-connect');
    grunt.loadNpmTasks('grunt-fest');

};
~~~
{:.javascript}

Установите `grunt-contrib-watch` и настройте таск `watch`. Удалите опцию `keepalive` у задачи `connect`, чтобы было возможным запустить одновременно задачи `connect` и `watch`.

~~~
module.exports = function (grunt) {

    grunt.initConfig({
        watch: {
            fest: {
                files: ['templates/*.xml'], /* следим за шаблонами */
                tasks: ['fest'], /* перекомпилировать */
                options: {
                    atBegin: true /* запустить задачу при старте */
                }
            }
        },
        connect: {
            server: {
                options: {
                    port: 8000,
                    base: 'public'
                }
            }
        },
        fest: {
            templates: {
                files: [{
                    expand: true,
                    cwd: 'templates',
                    src: '*.xml',
                    dest: 'public/js/tmpl'
                }],
                options: {
                    template: function (data) {
                        return grunt.template.process(
                            'var <%= name %>Tmpl = <%= contents %> ;',
                            {data: data}
                        );
                    }
                }
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.loadNpmTasks('grunt-contrib-connect');
    grunt.loadNpmTasks('grunt-fest');

    grunt.registerTask('default', ['connect', 'watch']); /* задача по умолчанию */

};
~~~
{:.javascript}

Добавьте [`livereload`](https://github.com/gruntjs/grunt-contrib-watch#optionslivereload).

~~~
module.exports = function (grunt) {

    grunt.initConfig({
        watch: {
            fest: {
                files: ['templates/*.xml'],
                tasks: ['fest'],
                options: {
                    atBegin: true
                }
            },
            server: {
                files: [
                    'public/js/**/*.js', /* следим за статикой */
                    'public/css/**/*.css'
                ],
                options: {
                    interrupt: true,
                    livereload: true /* перезагрузить страницу */
                }
            }
        },
        connect: {
            server: {
                options: {
                    livereload: true, /* поддержка перезагрузки страницы */
                    port: 8000,
                    base: 'public'
                }
            }
        },
        fest: {
            templates: {
                files: [{
                    expand: true,
                    cwd: 'templates',
                    src: '*.xml',
                    dest: 'public/js/tmpl'
                }],
                options: {
                    template: function (data) {
                        return grunt.template.process(
                            'var <%= name %>Tmpl = <%= contents %> ;',
                            {data: data}
                        );
                    }
                }
            }
        }
    });

    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.loadNpmTasks('grunt-contrib-connect');
    grunt.loadNpmTasks('grunt-fest');

    grunt.registerTask('default', ['connect', 'watch']);

};
~~~
{:.javascript}

Подключите [jQuery](http://jquery.com). Создайте функции для отрисовки каждого из экранов игры.

~~~
var $page = $('#page');

/* Конструктор экрана "Лучшие игроки" */
function showScoreboardScreen() {
    hideMainScreen();
}

/* Деструктор экрана "Лучшие игроки" */
function hideScoreboardScreen() {}

/* Конструктор экрана "Игра" */
function showGameScreen() {
    hideMainScreen();
}

/* Деструктор экрана "Игра" */
function hideGameScreen() {}

/* Конструктор экрана "Главный" */
function showMainScreen() {
    $page.html(mainTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-scoreboard').on('click', showScoreboardScreen);
    $page.find('.js-start-game').on('click', showGameScreen);
}

/* Деструктор экрана "Главный" */
function hideMainScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-scoreboard').off('click', showScoreboardScreen);
    $page.find('.js-start-game').off('click', showGameScreen);
}

showMainScreen();
~~~
{:.javascript}

Заключительный вариант.

~~~
var $page = $('#page'),
    currentScreen = 'main';

/* Конструктор экрана "Лучшие игроки" */
function showScoreboardScreen() {
    hideMainScreen(); // Убиваем экран "Главный"
    currentScreen = 'scoreboard';
    $page.html(scoreboardTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-back').on('click', showMainScreen);
}

/* Деструктор экрана "Лучшие игроки" */
function hideScoreboardScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-back').off('click', showMainScreen);
}

/* Конструктор экрана "Игра" */
function showGameScreen() {
    hideMainScreen(); // Убиваем экран "Главный"
    currentScreen = 'game';
    $page.html(gameTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-back').on('click', showMainScreen);
}

/* Деструктор экрана "Игра" */
function hideGameScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-back').off('click', showMainScreen);
}

/* Конструктор экрана "Главный" */
function showMainScreen() {
     // Убиваем текущий экран
    if (currentScreen === 'scoreboard') {
        hideScoreboardScreen();
    } else if (currentScreen === 'game') {
        hideGameScreen();
    }
    currentScreen = 'main';
    $page.html(mainTmpl()); // Рендерим шаблон
    // Инициализируем обработчики событий
    $page.find('.js-scoreboard').on('click', showScoreboardScreen);
    $page.find('.js-start-game').on('click', showGameScreen);
}

/* Деструктор экрана "Главный" */
function hideMainScreen() {
    // Удаляем установленные обработчики событий
    $page.find('.js-scoreboard').off('click', showScoreboardScreen);
    $page.find('.js-start-game').off('click', showGameScreen);
}

showMainScreen();
~~~
{:.javascript}

### 1.1.3 Домашнее задание
{: id="1.1.3"}

1. Сформировать идею игры.
2. Определиться с группой и ролями в ней.
3. Самостоятельно изучить документацию Grunt и сопутствующие расширения, Fest и jQuery.
4. Создать прототип веб-приложения.

### 1.1.4 Техническое задание
{: id="1.1.4"}

1. Прототип состоит из трех экранов:
    1. Главный экран (Main Screen). Содержит название игры и пункты главного меню:
        - Пункт «Лучшие игроки» ведет на экран «Лучшие игроки».
        - Пункт «Начать игру» ведет на основной экран игры.
    2. Лучшие игроки (Scoreboard Screen). Содержит название игры и кнопку «Назад», ведущую на главный экран.
    3. Основной экран игры (Game Screen). Содержит кнопку «Назад», ведущую на главный экран.
2. За отрисовку и последующую инициализацию каждого экрана должна отвечать отдельная функция в JavaScript.
3. При первой загрузке страницы с игрой появляется главный экран. Переход между экранами должен осуществлятся без перезагрузки страницы.
4. Для шаблонизации на строне клиента должен использоваться Fest (см. [`grunt-fest`](https://npmjs.org/package/grunt-fest) и [Fest](https://github.com/mailru/fest)).
5. На странице с игрой допускается загрузка одного JavaScript файла и одного CSS файла. Сборку этих файлов необходимо осуществить с помощью Grunt (см. [`grunt-contrib-concat`](https://npmjs.org/package/grunt-contrib-concat)).
6. С помощиью Grunt возможно запустить веб-сервер с игрой (см. [`grunt-contrib-connect`](https://npmjs.org/package/grunt-contrib-connect)). Страницу с игрой необходимо автоматически перезагружать при изменении исходных JavaScript, XML (Fest) или CSS файлов (см. параметр `livereload` в задачах `grunt-contrib-connect` и [`grunt-contrib-watch`](https://npmjs.org/package/grunt-contrib-watch)).

![Схема прототипа](/pics/prototype-scheme.png)

## 1.2 Архитектура веб-приложений
{: id="1.2"}

### 1.2.1 Полезные ресурсы
{: id="1.2.1"}

1. Addy Osmani. [Patterns For Large-Scale JavaScript Application Architecture](http://addyosmani.com/largescalejavascript/) // 2011.
2. Эдди Османи. [Паттерны для масштабируемых JavaScript-приложений](http://largescalejs.ru) // 2011.
3. Addy Osmani. [Developing Backbone.js Applications](http://addyosmani.github.io/backbone-fundamentals/) // 2013.
4. Документация [Backbone.js](http://backbonejs.org).
5. Неофициальный перевод документации [Backbone.js](http://backbonejs.ru).
6. Документация [RequireJS](http://requirejs.org/).
7. Неофициальный перевод документации [RequireJS](http://requirejs.ru).
8. Документация [Underscore](http://underscorejs.org/).
9. Неофициальный перевод документации [Underscore](http://underscorejs.ru/).

### 1.2.2 Смешанное занятие
{: id="1.2.2"}

Сегодняшнее занятие будет посвящено устройству современных веб-приложений и хорошим практикам. Начнем с одной из них — работой с глобальной областью видимости в JavaScript.

Глобальные переменные в JavaScript доступны везде, локальные — только в области видимости, в которой они определены. Областью видимости локальных переменных является функция. Глобальные переменные являются свойствамии объекта `window`.

~~~
function quz() {
    foo = {}; /* глобальная переменная */
    window.foo === foo; /* true */
    var bar = {}; /* локальная переменная */
    window.bar === bar; /* false */
}
~~~
{:.javascript}

Поэтому, объявляя глобальные переменные, вы рискуете изменить свойства `window`. Каждый раз при присвоении значения неопределенной локальной переменной, вы создаете или изменяете глобальную. Использование глобальных переменных является плохой практикой. В текущей спецификации JavaScript отсутствуют модули, которые бы разграничивали области видимости переменных, объявленых внутри. Но существуют несколько приемов, позволяющих реализовать модульность.

~~~
var foo = 1;
(function () {
    var foo = 2;
    alert(foo); // 2
})();
alert(foo); // 1
~~~
{:.javascript}

Конструкция в примере выше называется *немедленно-вызываемая функция* (Immediately-Invoked Function Expression, IIFE). Мы создаем анонимную функцию и незамедлительно вызываем ее, с параметрами или без.

Пока что наша функция ничего не возвращает, и модулем назвать ее сложно. Рассмотрим пример по сложнее.

~~~
var module = (function () {
        var name = 'A'; // приватная переменная
        return {
            say: function () { // публичный метод
                alert(name); // 2
            }
        };
    })();
~~~
{:.javascript}

На этот раз немедленно-вызываемая функция возвращает объект, определяющий интерфейс модуля, с которым уже можно работать в других частях веб-приложения. Такой подход предотвращает попадание приватных переменных и функций в глобальный контекст, где они могут конфликтовать с другими интерфейсами.

В отличии от некоторых других языков программирования, JavaScript не поддерживает модификаторы доступа. Область видимости ограничивает доступность объявленных в ней переменных. Таким образом, объявленные внутри модуля переменные и функции доступны только изнутри этого модуля, а свойства объекта, возвращаемого модулем, будут доступны всем.

При разработке сервер-сайда веб-приложения популярен подход [MVC](http://ru.wikipedia.org/wiki/Model-View-Controller) (Model-View-Controller). Обработкой запроса к серверу занимается контроллер (Controller). Контроллер обращается за данными к модели (Model), которая общается с базой данных. Полученые от модели данные контроллер отправлят в представление (View) для формирования ответа на поступивший запрос.

![MVC сервер-сайда](/pics/mvc-ss.png)

Так вот, при разработке клиент-сайда больших веб-приложения тоже применяется подход MVC, но в действительности он работает по-другому. Во главе теперь стоит модель. При изменении своего состояния модель оповещает об этом всех слушателей. Представление это интерфейс, то что видит пользователь и с чем работает. Представление следит за изменения модели и реагирует на них. Но когда пользователь взаимодействует с представлением (например, выполнилняет click по кнопке), представление передает управление контроллеру. Последний в свою очередь вносит изменения в модель и все начинается сначала.

![MVC клиент-сайда](/pics/mvc-cs.png)

Как устроен клиент-сайд сложного веб-приложения?

Уровень библиотек.
Уровень ядра приложения.
Уровень модулей.

> Модуль — функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом… предназначенный для использования в других программах [[Википедия](http://ru.wikipedia.org/wiki/Модуль_(программирование\))].

Модуль веб-приложения состоит из HTML, CSS и JavaScript. Модули характеризуются [связанностью](http://ru.wikipedia.org/wiki/Связанность_(программирование\)). Слабая связанность позволяет вносить изменения в один модуль не оказывая при этом влияния на остальные.

Давайте посмотрим на одно из популярный веб-приложений — «Почту».

![Почта](/pics/email.png)

Веб-приложение состоит из многих модулей, вот некоторые из них.

Портальное меню (`portal-menu`).
![Модуль Портальное меню](/pics/email-portal-menu.png)

Тулбар (`toolbar`).
![Модуль Тулбар](/pics/email-toolbar.png)
![Модуль Тулбар](/pics/email-toolbar-2.png)

Навигация (`nav`).
![Модуль Навигация](/pics/email-nav.png)

Список писем (`letters`).
![Модуль Список писем](/pics/email-datalist.png)

Чтобы модули обладали слабой связанностью не только на уровне логическом (JavaScript), но и на уровне представления (CSS), мы в разработке придерживаемся методологии [БЭМ](http://ru.bem.info/).

Что такое БЭМ?

БЭМ расшифровывается как «Блок, Элемент, Модификатор». Это методология разработки веб-проектов, способ удобно делить интерфейс на отдельные блоки и элементы.

Модуль – это блок в терминологии БЭМ. Блок состоит из элементов или других блоков. Например блок `toolbar`, который показан на рисунках выше, состоит из элементов – кнопок `toolbar__button`.

Кнопка тулбара (`toolbar__button`).
![Элемент toolbar__button](/pics/email-toolbar__button.png)

Согласно БЭМ, в имени элемента обязательно должно присутствовать имя блока, которому он принадлежит, и для их разрграничения обычно используется два нижних подчеркивания. Сделано это для того, чтобы минимизировать количество контекстных селекторов при описании стилей блоков и элементов. Зачем это необходимо?

В качестве примера рассмотрим простейший пример реализации кнопки в тулбаре.

~~~
<div class="toolbar">
    <div class="button">Click Me</div>
</div>
~~~
{:.html}

~~~
.toolbar .button {
    background: white;
}
~~~
{:.css}

А теперь поместим этот тулбар в окошко, в котором тоже есть кнопки, но другие.

~~~
<div class="window">
    <div class="toolbar">
        <div class="button">Click Me</div>
    </div>
    <button class="button">Submit</button>
</div>
~~~
{:.html}

~~~
.toolbar .button {
    background: white;
}
.window .button {
    background: black;
}
~~~
{:.css}

Обе кнопки в примере выше будут черного цвета. Цвет кнопки внутри `toolbar` оказался перебит значением, заданным по умолчанию для кнопок внутри блока `window`. Мы оказались в ситуации, когда визуальное оформление элемента `button` блока `toolbar`, зависит от окружения, в которое помещен блок. БЭМ позволяет свести такие ситуации к нулю. За счет отказа от использования контекстных селекторов, мы достигаем практически нулевой связности между блоками, блоки становятся независимыми от того окружения, в котором они окажутся.

~~~
<div class="window">
    <div class="toolbar">
        <div class="toolbar__button">Click Me</div>
    </div>
    <button class="window__button">Submit</button>
</div>
~~~
{:.html}

~~~
.toolbar__button {
    background: white;
}
.window__button {
    background: black;
}
~~~
{:.css}

Теперь элементы `toolbar__button` и `window__button` являются независимыми. У таког подхода ко всему прочему есть еще один приятный момент — скорость отрисовки страниц. Чем сложнее селекторы в каскадной таблице стилей, тем больше времени браузер потратит на определение стилей элементов страницы. Так как, разбор составного селектора происходит справа налево, то есть сначала выбираются элементы, удовлетворяющие самому правому селектору, затем для каждого найдено элемента происходит поиск родительского, удовлетворяюего следующему селектору.

Одни и теже блоки и элементы не всегда выгледят одинаково в итерфейсе. Например, они могут отличаться геометрическими размерами или отличаться графическим содержанием (как это бывает с иконками у тех же самых кнопок). Для этих целей в БЭМ предусмотрены модификаторы. Модификатор это класс, который применяется дополнительно к блоку или элементу с целью изменения его представления. В имени модификатора обязательно присутствует имя блока или элемента, который он изменяет, а для разграничения используется один символ нижнего подчеркивания. Например, `toolbar_fixed` (модификатор `fixed` блока `toolbar`) или `toolbar__button_size_xl` (модификатор `size` в значении `xl` элемента `button` блока `toolbar`).

БЭМ позволяет гарантировать результат при внесении правок в уже существующие блоки, а как показывает опыт, большую часть времени код не пишеться, а поддерживается.

Веб-приложение представляет собой результат работы модулей, из которых оно состоит.

Когда модули слабо связаны между собой, то удаление одного, не приведет к некорректной работе остальных модулей. Поэтому, модули не должны напрямую обращаться к методам других модулей, вместо этого модули отправляют и принимают собщения. Это частный случай событийно-ориентированного программрования, который применяется при разработки пользовательских интерфейсов.

Ядро веб-приложения отвечает за управление модулями (загрузка, инициализация и освобождение ресурсов), предоставляет средства коммуникации между модулями и занимается обработкой ошибок в приложении.

На уровне библиотек находятся инструменты для работы с DOM, AJAX, парсеры и т.п.

При разработке проектной работы мы будем использовать довольно популярный стек технологий:

1. Уровень библиотек: jQuery и [Underscore](http://underscorejs.org/).
2. Уровень ядра приложения: [Backbone](http://backbonejs.org/).
3. Уровень моделуй: [AMD](https://github.com/amdjs/amdjs-api/wiki/AMD) и [RequireJS](http://requirejs.org/).

Underscore это библиотека для манипулирования данными в функциональном стиле. Без этой библиотеки не обойтись при использовании Backbone. Существует более быстрая реализация Underscore – [Lo-Dash](http://lodash.com/). При желании, можете использовать ее в своей проектной работе.

Мы уже видели как можно создавать модули в JavaScript с помощью анонимных функций. Теперь когда мы умеем разбивать сложное веб-приложение на модули, то становится актуальной проблема управления зависимостями между модулями. Например, для работы контроллера «Списка писем» необходимы модули с реализацией моделей письма и коллекции писем, а так же модуль работы с представлением списка писем.

Мы рассмотрим, пожалуй, самый популярный механиз определения модулей и их зависимостей в JavaScript. Речь идет о AMD (Asynchronous Module Definition).

Вернемся к примеру с простейшей реализацией модуля в JavaScript.

~~~
var A = (function () {
        var name = 'A'; // приватная переменная
        return {
            say: function () { // публичный метод
                alert(name);
            }
        };
    })();
~~~
{:.javascript}

В AMD этот модуль следует определить следующим образом:

~~~
define('A', function () {
    var name = 'A'; // приватная переменная
    return {
        say: function () { // публичный метод
            alert(name);
        }
    };
});
~~~
{:.javascript}

А следующая запись определяет модуль `B`, который зависит от модуля `A`.

~~~
define('B', ['A'], function (A) {
    var name = 'B'; // приватная переменная
    return {
        say: function () { // публичный метод
            A.say(); // обращение к публичному методу модуля A
            alert(name);
        }
    };
});
~~~
{:.javascript}

Интерфейсы зависимых модулей передаются в качестве параметров в функцию-конструктор определяемого модуля. AMD это не библиотека, это спецификация, и функция `define` не определена в JavaScript. Для загрузки модулей, определенных с помощью механизма AMD, используется RequireJS.

Теперь разберемся с ядром веб-приложения. Оно построено будет с использованием Backbone.

Backbone состоит из моделей (models), коллекций (collections) и представлений (views). Как вы заметили, контроллеры отсутсвуют в Backbone. Представления в Backbone, в отличие от MVC, знают что делать при взаимодействии пользователя с ними.

Данные, с которыми оперирует ваше веб-приложение, в Backbone представлены моделями, которые можно создавать, изменять, валидировать, уничтожать или сохранять на сервере. При каждом изменении данных в моделе, модель бросает событие `change`, что позволяет среагировать на эти измения, например, перерисовать часть интерфейса. Модель используется для представления сущности, а для представления множества сущностей используются коллекции. Например, на экране «Лучшие игроки» в нашей проектной работе будет выводиться список игроков, отсортированный по количеству заработанных очков. Модель — игрок, коллекция – список игроков. Backbone предоставляет методы для манипулирования коллекциями. В нашем случае потребуется упорядочить коллекцию по значению атрибута «счет» модели.

Базовым объектом в Backbone является `Events`. Любой другой объект, к которому примиксовать `Events`, унаследует возможность бросать и подписывать произвольные события. Например:

~~~
var object = {};

_.extend(object, Backbone.Events);

object.on("alert", function (msg) {
  alert("Triggered " + msg);
});

object.trigger("alert", "an event");
~~~
{:.javascript}

В этом примере мы создаем объект `object`, и с помощью метода `extend` библиотеки `Underscore` переносим в него методы из объекта `Backbone.Events`, это и есть миксование. Теперь нам доступны в объекте `object` методы `on` и `trigger`, которые используюся для подписки на событие и инициирования события соотвественно.

Объект `Events` уже примиксован к остальным объектам Backbone, например, таким как `Model` или `Collection`.

~~~
var PlayerModel = Backbone.Model.extend({
    });

var player = new PlayerModel();

player.on('change:name', function(model, name) {
    alert('Player name is ' + name);
});

player.set({name: 'Mark'});
~~~
{:.javascript}

Здесь мы создаем модель `PlayerModel`, а затем создаем экземпляр `player` созданной модели. Создаем обработчик события `change:name` для объекта `player` и устанавливаем значение атрибута `name`, используя метод `set`. Последний приведет к инициализации события `change:name`, для которого мы создали обработчик.

Обратимся к представлениям – объекты `View` в Backbone. `View` не привязаны к какому-либо шаблонизатору, например, будет достаточно того, что есть в библиотеке `Underscore`, от которой зависит Backbone. Напомню, мы будем использовать шаблонизатор Fest.

~~~
var PlayerView = Backbone.View.extend({

    tagName: "li",
    className: "score__item",
    template: fest['player'],

    events: {
        "click .button_delete": "destroy"
    },

    initialize: function () {
        this.listenTo(this.model, "change", this.render);
    },

    render: function () {
        this.$el.html(this.template(this.model.attributes));
        return this;
    },

    destroy: function () {

    }
});

var playerView = new PlayerView({
        model: player,
        id: "player-" + player.id
    });
~~~
{:.javascript}

Здесь мы создаем представление `PlayerView` и переопределяем значения по умолчанию для следующих свойств представлений. Свойство `tagName` указывает на тип HTML элемента, который будет создан, если при создании экземпляра представления не будет передан уже существующий элемент в свойстве `el`. Таким образом, у представления всегда есть элемент. Находится он в DOM или нет – неважно. Свойство `className` определяет значение аттрибута `class` для создаваемого элемента `tagName`. В свойство `template` необходимо передать функцию-шаблонизатор. Свойство `events` позволяет в удобном виде определить обработчики событий на элементах этого представления. В примере выше метод представления `destroy` будет назначен обработчиком события `click` на элементах с классом `button_delete`. Свойство `initialize` определяет функцию, которая будет вызвана при создании экземпляра представления. Здесь мы подписываемся на событие `change` модели, ассоциированной с созданным экземпляром нашего представления, а в качестве обработчика события указываем метод `render`. То есть при любых изменения в моделе, будем перерисовывать представление. Метод `listenTo`, унаследованный от объекта `Events`, позволяет создавать обработчик события и связать его с текущим контекстом. Свойство `render` определяет функцию, которая будет отвечать за перерисовку представления. В нашем случае в элемент, который связан с экземпляром представления, мы вставляем результат вызова функции-шаблонизатора.

Вашим предыдущим домашним заданием было сделать прототип веб-приложения, в котором переключение между экранами не приводило к перезагрузке страницы. Вы просто изменяли содержимое элемента страницы, при этом адрес у страницы оставался неизменным. Это неудобно по следующим причинам:

1. Чтобы попасть на определенный экран, каждый раз необходимо совершать последовательность действий, приводящих к его появлению.
2. Переходы между экранами не отображатся в истории навигации веб-браузера. При переходе на новый экран, нет возможности перейти к предыдущему по нажатию на кнопку Back веб-браузера.

Для решения этих проблем используется механизм с подменой якоря страницы. Якорь — это часть URL страницы. Начинается с символа `#` и всегда находится в конце URL. Если каждому экрану в нашем веб-приложении назначить уникальный якорь и начать отслеживать изменение этого якоря в адресе страницы, то пропадает необходимость в обработчиках события `click` для ссылок, которые осуществляют переход между экранами. Достаточно указать нужное значение якоря в артрибуте `href` и воспользоваться функционалом, который предоставляет Backbone.

~~~
<a href="#" class="js-scoreboard">Scoreboard</a>
<a href="#" class="js-game">Game</a>
<script>
    $('.js-scoreborad').on("click", function () { … });
    $('.js-game').on("click", function () { … });
</script>
~~~
{:.html}

~~~
<a href="#scoreboard">Scoreboard</a>
<a href="#game">Game</a>
~~~
{:.html}

Для того, что бы Backbone начал отслеживать изменения якоря в адресе страницы, необходимо вызвать `Backbone.history.start()` когда документ будет уже загружен. Как это работает? Все очень просто, веб-браузер при изменении якоря бросает событие  `hashchange` от имени `window`, а Backbone начинает его слушать.

Важной частью современного веб-приложения является роутинг. Это механизм, который позволяет устанавливать связь между адресом страницы и действиями, которые необходимо выполнять каждый раз при измении адреса страницы на указанное значение. В Backbone за роутинг отвечает объект `Router`.

~~~
var Router = Backbone.Router.extend({
    routes: {
        'scoreboard': 'scoreboardAction',
        'game': 'gameAction',
        '*default': 'defaultActions'
    },
    scoreboardAction: function () {},
    gameAction: function () {},
    defaultActions: function () {}
});

new Router();
~~~
{:.javascript}

В этом примере мы указываем, что при изменении якоря на значение `#scoreboard` следует выполнить метод экземпляра объекта `scoreboardAction`, при значении якоря равным `#game` – выполнить метод `gameAction`, а для всех остальных значений якоря – метод `defaulActions`. И неважно каким образом был изменен якорь страницы (программно или пользователь ввел его в адресной строке), роутер выполнит указанные обработчики.

Подробное изучение возможностей Backbone не является целью нашего занятия, это будет вашим домашним заданием. Поэтому мы двигаемся дальше.

Наше веб-приложение необходимо разбить на мелкие модули и определить зависимости между ними. Мы будем использовать механизм AMD и придерживаться соглашения «один модуль — один файл».

Напомню, что шаблоны Fest мы компилируем в JavaScript файлы с помощью Grunt. Поэтому необходимо изменить процедуру формирования этих файлов. Для этого в `Gruntfile.js` необходимо заменить значение параметра `template` задачи `fest` на следующее:

~~~
template: function (data) {
    return grunt.template.process(
        // 'var <%= name %>Tmpl = <%= contents %> ;',
        'define(function () { return <%= contents %> ; });',
        {data: data}
    );
}
~~~
{:.javascript}

Для загрузки модулей, определенных с помощью механизма AMD, используется RequireJS. С помощью RequireJS достаточно указать на странице всего один JavaScript файл, и все зависимые модули будут автоматически им загружены. Это очень сильно упращает разработку. Сравните, как у нас подключались JavaScript файлы до этого:

~~~
<script src="/js/lib/jquery.js"></script>
<script src="/js/tmpl/main.js"></script>
<script src="/js/tmpl/scoreboard.js"></script>
<script src="/js/tmpl/game.js"></script>
~~~
{:.html}

И как станут подключаться теперь:

~~~
<script data-main="js/main" src="js/lib/require.js"></script>
~~~
{:.html}

Здесь мы подключаем на страницу только саму библиотеку RequireJS и указываем в атрибуте `data-main` имя файла, который следуем загрузить после того как библиотека проинициализируется. Файл `js/main.js` содержит настройки для RequireJS и определяет загрузочный модуль. В нашем случае загрузочный модуль содержит всего одну инструкцию (инициализирование `Backbone.history`) и зависит от модуля с роутером:

~~~
define([
    'router'
], function () {
    Backbone.history.start();
});
~~~
{:.javascript}

Благодаря AMD и RequireJS вам больше не нужно следить, чтобы все необходимые файлы были подключены к странице в определенном порядке. Они сделают это все за вас.

Дело за малым — настроить роутинг, реализовать представления, коллекции и модели. Это будет вашим домашним заданием. Мы подготовили структуру проекта, определили все модули-пустышки, необходимые для запуска веб-приложения. Для этого вам потребуется к репозиторию вашего проекта добавить репозиторий [github.com/eprev/frontend-stub/](https://github.com/eprev/frontend-stub/) и влить содержимое ветки v2:

~~~
$ git remote add tp https://github.com/eprev/frontend-stub.git
$ git fetch tp
$ git merge tp/v2
~~~

При разрешении конфликтов Git, файлы `templates/*.xml` и `public/css/main.css` следует разрешить в пользу ваших версий, в то время как для `index.html` и `public/js/main.js` использовать версии из `tp/v2`. Для разрешения конфликтов в `public/js/tmpl/*.js` достаточно их пересобрать с помощью Grunt (`grunt fest`).

### 1.2.3 Домашнее задание
{: id="1.2.3"}

1. Самостоятельно изучить документацию Underscore, Backbone, RequireJS и БЭМ.
2. Доработать прототип в соотвествии техническому заданию.
3. Приступить к реализация игровой механики.

### 1.2.4 Техническое задание
{: id="1.2.4"}

Необходимо доработать прототип первого домашнего задания в соотвествии с организацеий [frontend-stub/v2](https://github.com/eprev/frontend-stub/tree/v2) (Grunt, Backbone, RequireJS, Fest). Достаточно подключить к репозиторию проектной работы [github.com/eprev/frontend-stub](https://github.com/eprev/frontend-stub) и объединить содержимое своего проекта с содержимым ветки v2.

1. Должны отсутствовать JavaScript ошибки при работе веб-приложения.

2. Обязательно использование БЭМ методологии в HTML и CSS.

3. Модель игрока (`public/js/models/score.js`) должна состоять из следующих атрибутов:

    - `name` – имя игрока (значение по умолчанию: `''`)
    - `score` – количество очков (значение по умолчанию: `0`)

4. Список игроков (`public/js/views/scoreboard.js`) должен состоять из 10 разных записей и программно упорядочен по убыванию атрибута `score`.

5. Переходы между экранами веб-приложения должны отражаться в истории веб-браузера, таким образом, чтобы корректно работали кнопки Back и Forward. Для этой цели к адресу веб-страницы добавляется якорь (`#`):

    - `#scoreboard` для экрана «Лучшие игроки»;
    - `#game` для основного экрана игры;
    - `#` для экрана «Главное меню».

6. Роутер (`public/js/router.js`) должен работать только с представлениями (`public/js/views/*.js`); представления с шаблонами (`public/js/tmpl/*.js`), моделями (`public/js/models/*.js`) и коллекциями (`public/js/collections/*.js`); коллекции только с моделями.

7. Экран с игрой (`#game`) и/или главный экран (`#`) должен содержать наброски (в любом виде) будущей игры.
